- [分布式唯一ID](#分布式唯一id)
  - [1. 背景](#1-背景)
  - [2. 概念](#2-概念)
    - [2.1  什么是分布式唯一ID](#21--什么是分布式唯一id)
    - [2.2 分布式唯一ID的特性](#22-分布式唯一id的特性)
    - [2.3 单调递增和趋势递增](#23-单调递增和趋势递增)
    - [2.4 设计分布式ID系统需注意的点](#24-设计分布式id系统需注意的点)
    - [2.5 分布式ID系统的难点](#25-分布式id系统的难点)
  - [3. 分布式ID生成方案](#3-分布式id生成方案)
    - [3.1 UUID](#31-uuid)
      - [3.1.1 UUID概念](#311-uuid概念)
      - [3.1.2 UUID优缺点](#312-uuid优缺点)
      - [3.1.3 Java生成UUID](#313-java生成uuid)
    - [3.2 数据库自增](#32-数据库自增)
      - [3.2.1 概念](#321-概念)
      - [3.2.2 MySQL设置自增的方式](#322-mysql设置自增的方式)
    - [3.3 数据库集群模式](#33-数据库集群模式)
    - [3.4 数据库号段模式](#34-数据库号段模式)
    - [3.5 Redis/Zookeeper](#35-rediszookeeper)
    - [3.6 雪花算法](#36-雪花算法)
    - [3.7 美团Leaf算法](#37-美团leaf算法)
    - [3.8 百度uid-generator](#38-百度uid-generator)
    - [3.9 滴滴TinyId](#39-滴滴tinyid)
  - [4 参考资料](#4-参考资料)
# 分布式唯一ID
## 1. 背景

我们在设计和实现互联网系统时，往往需要使用到唯一ID。唯一ID标识唯一的一条业务请求，如在电商系统中，ID表示系统中唯一的一个订单，支付系统中表示唯一的一条交易请求。在单机应用中，唯一ID的生成是比较简单的，我们只需保证ID在单机上面是唯一的即可；但目前互联网应用多为微服务应用，同时随着业务的逐渐增长，必须对业务进行分库分表，而且业务应用往往是多实例部署的，这就要求ID在多个微服务应用和多个应用实例之间是唯一。目前业界有很多成熟的唯一ID生成方案，下面我们来看下这些分布式唯一的ID生成方案。

## 2. 概念

### 2.1  什么是分布式唯一ID

我的理解是；分库分表应用中多实例、各微服务应用之间全局唯一的ID即是分布式式唯一ID。

### 2.2 分布式唯一ID的特性

- 全局唯一：唯一ID，顾名思义；
- 高性能：ID生成的性能要高，否则会影响业务系统的性能；
- 高可用：ID生成服务要是高可用的，否则一旦出现不可用则会影响业务系统的可用性；
- 递增；尽量保证是递增的，因为业务系统可能需要根据ID进行排序，分为单调递增和趋势递增；
- 长度：长度尽可能的短；
- 侵入性小：尽量做到对业务系统无侵入。

此外，根据业务的不同，还可能要存在其他特性：

- 时间：有的ID中需要包含时间戳；
- 业务含义：这个要看具体的业务需求。

### 2.3 单调递增和趋势递增

- 单调递增：ID是严格递增的，后面的请求ID一定比之前的请求的ID大；
- 趋势递增：ID的整体趋势是递增的，不过存在后面的请求的ID比之前的请求ID小的情况。比如这样的ID生成方案：考虑这样的一个场景，2个实例的业务应用，实例1缓存0-1000的ID在进程中，实例2缓存1001-2000的ID在进程中，请求1先请求实例2（随机负载均衡），ID为1001，然后1分钟后请求2请求实例1，ID为0，即出现后面的请求的ID比之前的请求的ID小的情况，但是ID分配的整体趋势是递增的。

### 2.4 设计分布式ID系统需注意的点

- 时钟回退：如果ID中包含时间戳信息，需考虑时钟回退的场景，如果出现时钟回退则可能出现重复ID；
- 多线程问题：ID生成往往是在多线程的环境下的，因此需要注意多线程问题；
- 数据库性能：有些ID生成算法依赖数据库中的记录，需要考虑数据库的性能问题以及多线程引发的数据库锁问题

### 2.5 分布式ID系统的难点
- ID长度尽可能的短：我们的ID大多数是需要在数据库中存储的，越长的ID占用的空间越多；如果使用该ID作为MySQL的主键，主键也是要求尽可能的短的，所以ID长度要尽可能的短。随之而来的问题是，越短的ID，其中包含的信息越少（信息熵越小），冲突的可能性就越大；
- 多线程问题：多实例之间，同一实例之间的线程都会抢ID，因此必须注意多线程问题，解决方法大部分是加锁，如果线程之间竞争严重，则严重形象性能。


## 3. 分布式ID生成方案

### 3.1 UUID

#### 3.1.1 UUID概念

UUID(universally unique identifier)是一串随机的32位长度的数据，每一位是16进制表示，所以总计能够表示2^128的数字

据统计若每纳秒产生1百万个 UUID，要花100亿年才会将所有 UUID 用完

UUID的生成用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字

UUID为16进制的32字节长度，中间以`-`相连，形式为8-4-4-4-12，所以说长度也可以是36，不过使用时一般不包含`-`，UUID的形式如下：
```java
ef56e7fd-225b-44b8-b96d-4591bde0945b
********-****-M***-N***-************
```

> 上面的以数字`M`开头的四位表示UUID 版本，目前UUID的规范有5个版本，M可选值为1, 2, 3, 4, 5 ;各个版本的具体介绍如下所示：

> - version 1：0001。基于时间和 MAC 地址。由于使用了 MAC 地址，因此能够确保唯一性，但是同时也暴露了 MAC 地址，私密性不够好。
> - version 2：0010。DCE 安全的 UUID。该版本在规范中并没有仔细说明，因此并没有具体的实现。
> - version 3：0011。基于名字空间 (MD5)。用户指定一个名字空间和一个字符串，通过 MD5 散列，生成 UUID。字符串本身需要是唯一的。
> - version 4：0100。基于随机数。虽然是基于随机数，但是重复的可能性可以忽略不计，因此该版本也是被经常使用的版本。
> - version 5：0101。基于名字空间 (SHA1)。跟 Version 3 类似，但是散列函数编程了 SHA1。

> 上面以数字`N`开头的四个位表示 UUID 变体( variant )，变体是为了能兼容过去的 UUID，以及应对未来的变化，目前已知的变体有如下几种，因为目前正在使用的 UUID 都是 variant1，所以取值只能是 8，9，a，b 中的一个(分别对应1000,1001,1010,1011)。

> - variant 0：0xxx。为了向后兼容预留。
> - variant 1：10xx。当前正在使用的。
> - variant 2：11xx。为早期微软 GUID 预留。
> - variant 3：111x。为将来扩展预留。目前暂未使用。

#### 3.1.2 UUID优缺点

**优点**

- 无需网络，单机即可生成
- 速度快
- 生成简单，有内置的函数库可直接实现
- 没有业务含义，随机性较好，保密性强(业务层保密，有些版本的UUID可泄露IP或者MAC地址)
- 机器生成，可保证唯一，讲道理不会重复，但是也存在重复的概率(很低)

**缺点**

- 没有业务含义，如果ID中需要业务含义则不适用UUID
- 太长了，32位长度
- 无序，可读性差
- 有些版本的UUID可泄露IP或者MAC地址

#### 3.1.3 Java生成UUID

Java内置了`java.util.UUID`类，其中内置了四种版本的UUID生成策略,包括基于时间和MAC地址的、DCE 安全的UUID、基于名字空间(MD5)和基于随机数的: 

> There are four different basic types of UUIDs: time-based, DCE
> security, name-based, and randomly generated UUIDs.  These types have a
> version value of 1, 2, 3 and 4, respectively.

比较常用的即是基于随机数的UUID生成，下面是Java的使用方法

```java
    UUID.randomUUID().toString();
```

### 3.2 数据库自增

#### 3.2.1 概念

使用数据库的id自增策略,比如Mysql的auto_increment

**优点**

- ID单调递增，对业务友好，利于分页和排序；
- 简单，代码中无需设置，只需要在建表时设置主机递增即可；

**缺点**

- 依赖数据库, 性能存在瓶颈
- 单库时使用方便,分库分表后就难受了
- 难以扩展
- 只能主库生成,单点故障了就gg了
- 数据库语法不同,迁移时需要考虑
- 容易泄密,比如订单号是递增的,那么可以猜到别人的订单号

#### 3.2.2 MySQL设置自增的方式

只需设置主键自增即可,如下面的建表语句

```SQL
CREATE TABLE `user` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT 'id',
  `name` varchar(64) NOT NULL COMMENT '名字',
  `nick_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '昵称',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci;
```

### 3.3 数据库集群模式

### 3.4 数据库号段模式

### 3.5 Redis/Zookeeper

### 3.6 雪花算法

### 3.7 美团Leaf算法

### 3.8 百度uid-generator

### 3.9 滴滴TinyId

## 4 参考资料

- [分布式ID之UUID适合做分布式ID吗](https://www.itqiankun.com/article/1565060584)
- [UUID/GUID介绍、生成规则及生成代码](https://blog.csdn.net/lizongti/article/details/109000359)