{"./":{"url":"./","title":"Introduction","keywords":"","body":"前言 自己所学习的一些开发知识，希望都能够记录下来，在世界留下点痕迹... 使用Markdown语法编写，可直接在gitee中查看，也可以下载下来 gitee地址 gitpage地址 下载到本地的查看方法： markdown编辑器，推荐Typora和vs code + markdown all in one插件 gitbook 使用到的代码: https://gitee.com/gaoyang8320/java-notes gitbook使用方法： 运行gitbook服务 安装node 下载gitbook包npm install -g gitbook-cli 在本项目根目录下执行gitbook serve --port 23333后在浏览器中输入127.0.0.1:23333后即可 直接查看gitbook生成的html文件 在本项目根目录下_book文件夹中有对应的html文件 目录 powered by GitbookYoung, 该文件最后修改时间： 2021-05-20 20:40:24 "},"设计模式/readme.html":{"url":"设计模式/readme.html","title":"设计模式","keywords":"","body":"GOF23设计模式 powered by GitbookYoung, 该文件最后修改时间： 2021-05-22 18:54:40 "},"设计模式/00概述.html":{"url":"设计模式/00概述.html","title":"00设计模式概述","keywords":"","body":" 简介 设计模式的七种原则 单一职责原则 开闭原则 里氏替换原则 依赖倒置原则 接口隔离原则 迪米特法则 合成/聚合原则 23种设计模式的分类 简介 设计模式(Design Pattern)是经过高度抽象化的在编程中可以被反复使用的代码设计经验的总结 简单说设计模式就是经过实践验证的良好的编码经验 这里说的设计模式指的是GOF23，GOF指： 在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版> 了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：> 设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。 设计模式的七种原则 单一职责原则 就是一个类只有一个职责。 开闭原则 软件中的对象(类、模块、函数等)对扩展开放，对修改关闭；这意味着一个实体在不改变其源代码的前提下改变其行为。 里氏替换原则 里氏替换原则是对开闭原则的补充，规定了在任意父类可以出现的地方，其子类一定可以出现。一般面向对象的编程语言都支持该特性。 依赖倒置原则 程序依赖于抽象类，而不是具体的实现类，即面向接口编程。 接口隔离原则 不同的功能应该定义在不同的接口中，其实就是单一职责原则 迪米特法则 又名最少知道原则，就是一个实体应当尽量少地与其他实体之间发生相互作用，其核心思想在于降低模块之间的耦合度 合成/聚合原则 在新的对象中引入其他对象以达到类的功能服用和扩展的目的 23种设计模式的分类 设计模式按照其功能和使用场景可以分为3大类：创建型、结构型和行为型 类型 说明 设计模式 创建型 提供多种优雅创建对象的方法 简单工厂(不是23种之一但应用广泛) 工厂方法 抽象工厂 单例模式 建造者模式 原型模式 结构型 通过类和接口之间的继承和引用实现创建复杂结构对象 适配器模式 桥接模式 过滤器模式 组合模式 装饰器模式 外观模式 享元模式 代理模式 行为型 通过类之间不同的通信方式实现不同的行为方式 责任链模式 命令模式 解释器模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 模板模式 访问者模式 powered by GitbookYoung, 该文件最后修改时间： 2021-06-02 21:11:55 "},"设计模式/01工厂模式.html":{"url":"设计模式/01工厂模式.html","title":"01工厂模式","keywords":"","body":" 工厂模式 1. 简单工厂 1.1 简单工厂实现 1.2 简单工厂的优缺点 2. 工厂方法 2.2.1 工厂方法实现 2.2.2 工厂方法优缺点 2.3 抽象工厂 2.3.2 抽象工厂优缺点 2.4 三种工厂方法的适用场景 工厂模式 工厂模式提供了一种简单、快速、高效且安全地创建对象的方式， 工厂方法不直接创建对象，而将创建对象的过程放到对应的工厂类中实现， 如果后续需要修改对象， 只需更改工厂即可。 工厂模式可以分为三种： 简单工厂 工厂方法 抽象工厂 1. 简单工厂 1.1 简单工厂实现 在此以手机为例说明工厂方法，手机的品牌有华为、 小米、 VIVO、 OPPO等。 我们的需求是：根据客户传入的手机品牌名字来实例化一个手机对象。 如果是常规的写法， 我们需要根据传入的手机品牌名字来进行判断(if - else)，这样的就会导致代码中存在大量的if-else分支， 这样很不利于维护。 简单工厂的设计思想即是将实例化对象的过程放到工厂类中， 当我们需要对象时直接调用工厂类即可获取对象。 看下UML类图 1. 手机接口 /** * 手机接口 * * @author Young * @Date 2021-03-27 22:13 */ public interface Phone { /** * 返回手机名 * * @return */ String getName(); } 2. 各个手机对象， 包含华为、 小米、 VIVO、 OPPO /** * 华为手机 * * @author Young * @Date 2021-03-27 22:13 */ public class HuaWeiPhoneImpl implements Phone { @Override public String getName() { return \"我是华为手机\"; } } /** * 小米手机 * * @author Young * @Date 2021-03-27 22:09 */ public class XiaoMiPhoneImpl implements Phone { @Override public String getName() { return \"我是小米手机\"; } } /** * Vivo手机 * * @author Young * @Date 2021-03-27 22:11 */ public class VivoPhoneImpl implements Phone { @Override public String getName() { return \"我是VIVO手机\"; } } /** * OPPO手机 * * @author Young * @Date 2021-03-27 22:23 */ public class OppoPhoneImpl implements Phone { @Override public String getName() { return \"我是OPPO手机\"; } } 3. 手机工厂 /** * 手机工厂--简单工厂 * * @author Young * @Date 2021-03-27 22:25 */ public class PhoneSimpleFactory { public Phone getPhone(String phoneName) { switch (phoneName) { case \"VIVO\": return new VivoPhoneImpl(); case \"XiaoMi\": return new XiaoMiPhoneImpl(); case \"HuaWei\": return new HuaWeiPhoneImpl(); case \"OPPO\": return new OppoPhoneImpl(); default: return null; } } } 4. 简单工厂的使用 /** * 简单工厂测试 * * @author Young * @Date 2021-03-27 22:30 */ public class SimpleFactoryTest { public static void main(String[] args) { PhoneSimpleFactory phoneSimpleFactory = new PhoneSimpleFactory(); Phone phone = phoneSimpleFactory.getPhone(\"HuaWei\"); if (Objects.nonNull(phone)) { System.out.println(\"PhoneName: \" + phone.getName()); } } } 1.2 简单工厂的优缺点 优点 使用简单，只有一个工厂类，这个工厂能够生产多种产品 缺点 当产品较多时，工厂类会变得很庞大，而且任何一个产品的修改都会修改到该工厂类， 违反了单一职责原则； 当新增一个产品时，需要在工厂类中新增一个分支，违反了开闭原则。 2. 工厂方法 上文说简单工厂方法，当产品较多时，工厂类会变得很庞大，而且新增产品时，工厂类需要新增分支，违反单一职责原则和开闭原则。而工厂模式可以解决该问题。 2.2.1 工厂方法实现 还是以手机为例，与简单工厂不同， 工厂方法要求每个手机都要有自己的工厂类，当我们需要手机对象时，直接从对应的工厂中取即可。在手机的例子中，HuaWeiPhone有其对应的HuaWeiPhoneFactory工厂类， XiaoMiPhone有其对应的XiaoMiPhoneFactory工厂类，UML类图如下： 1. 手机接口和各手机对象的定义见简单工厂 2. 工厂接口 /** * 手机工厂接口 * * @author Young * @Date 2021-03-27 22:35 */ public interface PhoneFactory { /** * 返回手机对象 * * @return */ Phone getPhone(); } 3. 各工厂类 /** * 华为手机工厂 * @author Young * @Date 2021-03-27 22:34 */ public class HuaWeiPhoneFactory implements PhoneFactory{ @Override public Phone getPhone(){ return new HuaWeiPhoneImpl(); } } /** * 小米手机工厂 * * @author Young * @Date 2021-03-27 22:35 */ public class XiaoMiPhoneFactory implements PhoneFactory { @Override public Phone getPhone() { return new XiaoMiPhoneImpl(); } } /** * OPPO手机工厂 * * @author Young * @Date 2021-03-27 22:38 */ public class OppoPhoneFactory implements PhoneFactory { @Override public Phone getPhone() { return new OppoPhoneImpl(); } } /** * VIVO手机工厂 * * @author Young * @Date 2021-03-27 22:40 */ public class VivoPhoneFactory implements PhoneFactory { @Override public Phone getPhone() { return new VivoPhoneImpl(); } } 4. 工厂方法使用 /** * 工厂方法测试类 * * @author Young * @Date 2021-03-27 22:40 */ public class FactoryPatternTest { public static void main(String[] args) { // 从华为手机工厂中取华为手机 PhoneFactory huaWeiPhoneFactory = new HuaWeiPhoneFactory(); Phone huaWeiPhone = huaWeiPhoneFactory.getPhone(); System.out.println(huaWeiPhone.getName()); // 从小米手机工厂中取小米手机 PhoneFactory xiaoMiPhoneFactory = new XiaoMiPhoneFactory(); Phone xiaoMiPhone = xiaoMiPhoneFactory.getPhone(); System.out.println(xiaoMiPhone.getName()); } } 2.2.2 工厂方法优缺点 优点 工厂类只负责生产对应的产品，符合单一职责原则； 新增产品时，需要新增一个工厂类，符合开闭原则。 缺点 使用时需要知道具体的工厂类 2.3 抽象工厂 抽象工厂模式在工厂模式上添加了一个创建不同工厂的抽象接口(抽象类或者接口)，该接口可叫做超级工厂。在使用时， 首先根据不同的工厂接口创建不同的工厂对象，然后根据不同的工厂对象创建不同的对象。 可以将工厂模式理解为针对一个产品维度进行分类，比如简单工厂和工厂方法中的手机对象。而抽象工厂模式针对的是多个产品维度分类，比如华为即生产手机也生产电脑。 在同一个公司有多个维度的产品时，如果使用工厂模式，则势必会存在多个独立的工厂，即华为手机工厂和华为电脑工厂，而这样的设计和实际的物理世界是不对称的，这个问题可以通过抽象工厂方法来实现。可以将抽象工厂类比作公司(华为、小米)，将抽象工厂创建出来的工厂类比作产品(手机和电脑)，生产产品时根据抽象工厂进行生产， 看下UML类图： 1. 手机接口和其实现类见上文 2. 电脑接口和其实现类 /** * 电脑接口 * * @author Young * @Date 2021-03-28 13:13 */ public interface Computer { /** * 返回电脑 * * @return */ String getName(); } /** * 华为电脑 * @author Young * @Date 2021-03-28 13:18 */ public class HuaWeiComputerImpl implements Computer { @Override public String getName() { return \"我是华为笔记本电脑\"; } } /** * 小米笔记本 * * @author Young * @Date 2021-03-28 13:19 */ public class XiaoMiComputerImpl implements Computer { @Override public String getName() { return \"我是小米笔记本\"; } } 3. 抽象工厂接口 /** * 电子产品工厂(超级工厂) * * @author Young * @Date 2021-03-28 13:12 */ public interface ElectronicGoodsFactory { /** * 制造手机 * * @param phoneName * @return */ Phone getPhone(String phoneName); /** * 制造电脑 * * @param computerName * @return */ Computer getComputer(String computerName); } 4. 手机简单工厂 /** * 手机工厂 * * @author Young * @Date 2021-03-28 13:15 */ public class PhoneFactory implements ElectronicGoodsFactory { @Override public Phone getPhone(String phoneName) { switch (phoneName) { case \"VIVO\": return new VivoPhoneImpl(); case \"XiaoMi\": return new XiaoMiPhoneImpl(); case \"HuaWei\": return new HuaWeiPhoneImpl(); case \"OPPO\": return new OppoPhoneImpl(); default: return null; } } @Override public Computer getComputer(String computerName) { return null; } } 5. 电脑简单工厂 /** * 电脑工厂 * * @author Young * @Date 2021-03-28 13:17 */ public class ComputerFactory implements ElectronicGoodsFactory { @Override public Phone getPhone(String phoneName) { return null; } @Override public Computer getComputer(String computerName) { switch (computerName) { case \"HuaWei\": return new HuaWeiComputerImpl(); case \"XiaoMi\": return new XiaoMiComputerImpl(); default: return null; } } } 6. 抽象工厂测试类 /** * 抽象工厂测试类 * @author Young * @Date 2021-03-28 13:22 */ public class AbstractFactoryTest { public static void main(String[] args) { // 制造华为电脑 ElectronicGoodsFactory computerFactory = new ComputerFactory(); Computer huaWeiComputer = computerFactory.getComputer(\"HuaWei\"); System.out.println(huaWeiComputer.getName()); // 制造华为手机 ElectronicGoodsFactory phoneFactory = new PhoneFactory(); Phone huaWeiPhone = phoneFactory.getPhone(\"HuaWei\"); System.out.println(huaWeiPhone.getName()); } } 2.3.2 抽象工厂优缺点 优点 适用于不同维度的产品(不仅有手机，还有电脑)，可横向扩展产品以及产品种类 缺点 如果抽象工厂接口需要新增功能，则会影响所有的工厂实现类 2.4 三种工厂方法的适用场景 简单工厂: 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） 工厂方法: 用来生产同一等级结构中的固定产品。（支持拓展增加产品） 抽象工厂: 用来生产不同产品族的全部产品。（支持拓展增加产品；支持增加产品族） powered by GitbookYoung, 该文件最后修改时间： 2021-05-23 22:59:48 "},"设计模式/02单例模式.html":{"url":"设计模式/02单例模式.html","title":"02单例模式","keywords":"","body":" 单例模式 1. 饿汉式 2. 懒汉式(线程不安全) 3. 懒汉式(线程安全) 4. 双重校验锁 5. 静态内部类 6. 枚举类 6.1 破坏单例模式的几种方法 6.2 枚举实现的单例 7. 破坏单例模式的方法及解决办法 8. 参考资料 单例模式 单例模式的设计保证了一个类在整个系统中同一时刻只有一个实例存在，主要被用于一个全局类的对象在多个地方被使用并且对象的状态是全局变化的场景下。单例模式首先通过将类的实例化方法私有化来防止程序通过其他方式创建该类的实例， 然后通过提供一个全局唯一获取该类的实例的方法帮助用户获取类的实例，用户只需要也只能通过该方法获取类的实例。 单例模式的实现和简单，每次在获取对象前首先判断系统是否已经有这个单例对象，有则返回，没有则创建。 单例模式的写法主要包含： 饿汉式 懒汉式(线程不安全) 懒汉式(线程安全) 懒汉式(双重校验锁) 静态内部类 枚举类 1. 饿汉式 饿汉式指在类中直接定义全局的静态对象的实例并初始化，然后提供一个方法获取该实例对象。 优点是实现简单，但是如果该实例对象没有使用，该实例对象仍然会被实例化，浪费资源。 代码如下： /** * 单例模式 -- 饿汉式 * * @author Young * @Date 2021-05-24 20:53 */ public class HungerSingleton { private static final HungerSingleton HUNGER_SINGLETON = new HungerSingleton(); private HungerSingleton() { } public static HungerSingleton getHungerSingleton() { return HUNGER_SINGLETON; } } 2. 懒汉式(线程不安全) 懒汉式的\"懒\"记忆为懒加载，即在使用时才实例化 懒汉式是说在对象使用到的时候才会实例化，其实现也非常简单，代码如下： public class LazySingleton { private static LazySingleton LAZY_SINGLETON = null; private LazySingleton() { } /** * 线程不安全的实现方式 * * @return */ public static LazySingleton getLazySingletonUnsafe() { if (Objects.isNull(LAZY_SINGLETON)) { LAZY_SINGLETON = new LazySingleton(); } return LAZY_SINGLETON; } } 为什么说该方式是线程不安全的呢？ 假设我们有两个线程同时调用getLazySingletonUnsafe()方法，且拿到的LAZY_SINGLETON都是null，那么每个线程都会执行一次LAZY_SINGLETON = new LazySingleton();，这种情况将导致LAZY_SINGLETON被实例化2次，导致资源的浪费 3. 懒汉式(线程安全) 上一节中的方法是线程不全的，那么怎么才能做到线程安全呢？答案很简单，在方法上面加锁就可以了，实现也很简单，代码如下： public class LazySingleton { private static LazySingleton LAZY_SINGLETON = null; private LazySingleton() { } /** * 线程不安全的实现方式 * * @return */ public static synchronized LazySingleton getLazySingletonSafe() { if (Objects.isNull(LAZY_SINGLETON)) { LAZY_SINGLETON = new LazySingleton(); } return LAZY_SINGLETON; } } 但是该方法的缺点也很明显，每次调用getLazySingletonSafe()方法时都会加锁，我们知道加锁是比较耗时的，所以这种方法存在着性能问题的。 4. 双重校验锁 既然说加锁的操作存在性能问题，所以我们怎么做才能做到 每次调用getLazySingletonSafe()时不必加锁； 不必加锁时怎么保证线程安全的。 我们加锁的初衷是因为当LAZY_SINGLETON == null时需要防止实例对象被多次实例化，也就是当LAZY_SINGLETON == null时才需要加锁，所以可以做一下判断，当LAZY_SINGLETON == null时才加锁。所以我们可以这么写： /** * 单例模式 -- 双重校验锁 * * @author Young * @Date 2021-05-24 22:02 */ public class DoubleCheckSingleton { private volatile static DoubleCheckSingleton DOUBLE_CHECK_SINGLETON = null; private DoubleCheckSingleton() { } /** * 线程安全的实现方式（仍然线程不安全） * * @return */ public static DoubleCheckSingleton getDoubleCheckSingletonSafe() { if (Objects.isNull(DOUBLE_CHECK_SINGLETON == null)) { // 第一步， 当 DOUBLE_CHECK_SINGLETON为null时才对实例化对象的部分进行加锁 synchronized (DoubleCheckSingleton.class) { // 第二步， 一个时刻只有一个线程能到达这里 if (Objects.isNull(DOUBLE_CHECK_SINGLETON)) { // 第三步，这里还需要进一步判断， 如果线程1和线程2都执行到第一步，然后抢占锁，假设线程1抢到锁，成功进入synchronized代码块并实例化对象。然后实例2进入synchronized代码块中，这时DOUBLE_CHECK_SINGLETON已经不是null，如果不进行判断，则对象又会被实例化一次，所以在synchronized代码块中必须进行第二次的实例对象是否为空的判断 DOUBLE_CHECK_SINGLETON = new DoubleCheckSingleton(); } } } return DOUBLE_CHECK_SINGLETON; } } 为什么使用双重校验锁呢？ 第一次校验：也就是第一个if，这个是为了代码提高代码执行效率，由于单例模式只要一次创建实例即可，所以当创建了一个实例之后，再次调用getDoubleCheckSingletonSafe()方法就不必要进入同步代码块，不用竞争锁。直接返回前面创建的实例即可。 第二次校验：也就是第二个if，这个校验是防止二次创建实例，假如有一种情况，当DOUBLE_CHECK_SINGLETON还未被创建时，线程1调用getDoubleCheckSingletonSafe()方法，由于第一次判断if，此时线程1准备继续执行，但是由于资源被线程2抢占了，此时线程2调用getDoubleCheckSingletonSafe()方法，同样的，由于DOUBLE_CHECK_SINGLETON并没有实例化，线程2同样可以通过第一个if判断，然后继续往下执行进入同步代码块，第二个if也通过，然后线程2创建了一个实例LAZY_SINGLETON。此时线程2完成任务，资源又回到线程1，线程1此时也进入同步代码块，如果没有这个第二个if，那么，线程1就也会创建一个singleton实例，那么，就会出现创建多个实例的情况，但是加上第二个if，就可以完全避免这个多线程导致多次创建实例的问题。 为什么使用volatile关键字？ volatile关键字可以防止jvm指令重排优化 因为 DOUBLE_CHECK_SINGLETON = new DoubleCheckSingleton() 这句话可以分为三步： 为 DOUBLE_CHECK_SINGLETON 分配内存空间； 初始化DOUBLE_CHECK_SINGLETON; 将DOUBLE_CHECK_SINGLETON指向分配的内存空间。 但是由于JVM具有指令重排的特性，执行顺序有可能变成 1-3-2。 指令重排在单线程下不会出现问题，但是在多线程下会导致一个线程获得一个未初始化的实例。例如：线程1执行了1和3，此时线程2调用 getDoubleCheckSingletonSafe() 后发现DOUBLE_CHECK_SINGLETON不为空，因此返回DOUBLE_CHECK_SINGLETON， 但是此时的DOUBLE_CHECK_SINGLETON还没有被初始化。使用 volatile 会禁止JVM指令重排，从而保证在多线程下也能正常执行。 也即是： Time Thread A Thread B T1 检查到DOUBLE_CHECK_SINGLETON为空 T2 获取锁 T3 再次检查到DOUBLE_CHECK_SINGLETON为空 T4 为DOUBLE_CHECK_SINGLETON分配内存空间 T5 将DOUBLE_CHECK_SINGLETON指向内存空间 T6 检查到DOUBLE_CHECK_SINGLETON不为空 T7 访问DOUBLE_CHECK_SINGLETON（此时对象还未完成初始化） T8 初始化DOUBLE_CHECK_SINGLETON 在这种情况下，T7时刻线程B对DOUBLE_CHECK_SINGLETON的访问，访问的是一个初始化未完成的对象。 保证线程可见性 Java内存模型中，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 要解决这个问题，就需要把变量声明为 volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。 5. 静态内部类 静态内部类通过在类中定义一个静态内部类，将实例对象实例的定义和初始化放在内部类中完成，我们在获取对象时要通过静态内部类调用其单例对象。之所以这样设计，时因为类的静态内部类在JVM中是唯一的，这很好地保证了单例对象的唯一性。 静态内部类单例模式也称单例持有者模式，实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由static修饰，保证只被实例化一次，并且严格保证实例化顺序。 代码如下： /** * 单例模式 -- 静态内部类 * * @author Young * @Date 2021-05-25 20:48 */ public class StaticInnerClassSingleton { private static class SingletonHolder{ private static final StaticInnerClassSingleton STATIC_INNER_CLASS_SINGLETON = new StaticInnerClassSingleton(); } private StaticInnerClassSingleton() { } public static StaticInnerClassSingleton getInstance(){ return SingletonHolder.STATIC_INNER_CLASS_SINGLETON; } } 6. 枚举类 6.1 破坏单例模式的几种方法 clone: 为了防止客户端使用克隆方法来创建对象，单例类不能实现Cloneable接口，即不能支持clone()方法。 反射: 由于反射可以获取到类的构造函数，包括私有构造函数，因此反射可以生成新的对象。 序列化和反序列化: 在原型模式中，我们可以通过反序列化实现深克隆，反序列化也会生成新的对象。具体来说就是每调用一次readObject()方法，都将会返回一个新建的实例对象，这个新建的实例对象不同于类在初始化时创建的实例对象。 枚举类实现单例模式是 effective java 作者极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。 6.2 枚举实现的单例 /** * 单例模式 -- 枚举类 * * @author Young * @Date 2021-05-25 20:53 */ public enum SingletonEnum { SINGLETON_ENUM(\"SINGLETON_ENUM\", \"枚举单例测试\") ; SingletonEnum(String code, String desc) { this.code = code; this.desc = desc; } private String code; private String desc; /** * 实例执行方法 */ public void doSomething() { System.out.println(String.format(\"我是枚举单例...., code: %s, desc: %s\", code, desc)); } } /** * 单例模式 -- 枚举类 测试 * * @author Young * @Date 2021-05-25 20:56 */ public class SingletonEnumTest { public static void main(String[] args) { SingletonEnum.SINGLETON_ENUM.doSomething(); } } // 结果为： 我是枚举单例...., code: SINGLETON_ENUM, desc: 枚举单例测试 反编译上述枚举单例 D:\\IdeaProjects\\java-notes\\src\\main\\java\\com\\young\\design\\pattern\\creational\\singleton>javac -encoding UTF-8 SingletonEnum.java D:\\IdeaProjects\\java-notes\\src\\main\\java\\com\\young\\design\\pattern\\creational\\singleton>javap -encoding UTF8 SingletonEnum.class Compiled from \"SingletonEnum.java\" public final class com.young.design.pattern.creational.singleton.SingletonEnum extends java.lang.Enum { public static final com.young.design.pattern.creational.singleton.SingletonEnum SINGLETON_ENUM; public static com.young.design.pattern.creational.singleton.SingletonEnum[] values(); public static com.young.design.pattern.creational.singleton.SingletonEnum valueOf(java.lang.String); public void doSomething(); static {}; } 线程安全问题 由反编译后的代码可知，SINGLETON_ENUM是static，在Java虚拟机编译的时候，static变量赋值和static代码块是在()中执行，也即类加载后执行的，优先于非静态变量和非静态代码块以及构造函数。所以，枚举实现是在实例化时就已经保证是线程安全的了。 序列化问题 Java规范中规定，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，因此在枚举类型的序列化和反序列化上，Java做了特殊的规定。在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf() 方法来根据名字查找枚举对象。也就是说，以上述枚举为例，序列化的时候只将SINGLETON_ENUM这个名称输出，反序列化的时候再通过这个名称，查找对应的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。 7. 破坏单例模式的方法及解决办法 除枚举方式外, 其他方法都会通过反射的方式破坏单例, 反射是通过调用构造方法生成新的对象，所以如果我们想要阻止单例破坏，可以在构造方法中进行判断，若已有实例, 则阻止生成新的实例，解决办法如下: private SingletonObject1(){ if (instance !=null){ throw new RuntimeException(\"实例已经存在，请通过 getInstance()方法获取\"); } } 如果单例类实现了序列化接口Serializable, 就可以通过反序列化破坏单例，所以我们可以不实现序列化接口,如果非得实现序列化接口，可以重写反序列化方法readResolve(), 反序列化时直接返回相关单例对象。 public Object readResolve() throws ObjectStreamException { return instance; } 8. 参考资料 为什么用枚举类来实现单例模式越来越流行？ 单例模式之枚举实现 枚举实现单例模式的原理 深入理解jvm--Java中init和clinit区别完全解析 powered by GitbookYoung, 该文件最后修改时间： 2021-05-25 21:31:37 "},"设计模式/03建造者模式.html":{"url":"设计模式/03建造者模式.html","title":"03建造者模式","keywords":"","body":" 建造者模式 建造者模式 假设我们需要创建一个对象，该对象是由多个组件（Component）组合而成，每个组件的建立都比较复杂，但运用组件来建立所需的对象非常简单，所以我们就可以将构建复杂组件的步骤与运用组件构建对象分离，使用builder模式可以建立。 建造型模式用于创建过程稳定，但配置多变的对象，使用多个简单的对象一步一步构建成一个复杂的对象。 现在建造者模式主要用来通过链式调用生成不同的配置，比如我们要制作一杯珍珠奶茶。它的制作过程是稳定的，除了必须要知道奶茶的种类和规格外，是否加珍珠和是否加冰是可选的。使用建造者模式表示如下： public class MilkTea { private String type; private String size; private boolean pearl; private boolean ice; public MilkTea(Builder builder) { this.type = builder.getType(); this.size = builder.getSize(); this.pearl = builder.getPearl(); this.ice = builder.getIce(); } public String getType() { return type; } public void setType(String type) { this.type = type; } public String getSize() { return size; } public void setSize(String size) { this.size = size; } public boolean isPearl() { return pearl; } public void setPearl(boolean pearl) { this.pearl = pearl; } public boolean isIce() { return ice; } public void setIce(boolean ice) { this.ice = ice; } @Override public String toString() { return \"MilkTea{\" + \"type='\" + type + '\\'' + \", size='\" + size + '\\'' + \", pearl=\" + pearl + \", ice=\" + ice + '}'; } public static class Builder{ private String type = \"原味\"; private String size = \"中杯\"; private boolean pearl = false; private boolean ice = false; public Builder setType(String type) { this.type = type; return this; } public Builder setSize(String size) { this.size = size; return this; } public Builder setPearl(boolean pearl) { this.pearl = pearl; return this; } public Builder setIce(boolean ice) { this.ice = ice; return this; } public String getType() { return type; } public String getSize() { return size; } public boolean getPearl() { return pearl; } public boolean getIce() { return ice; } public MilkTea build(){ return new MilkTea(this); } } public static void main(String[] args) { MilkTea milkTea = new Builder().setType(\"111\").setSize(\"大杯\").build(); System.out.println(milkTea.toString()); } } powered by GitbookYoung, 该文件最后修改时间： 2021-05-28 18:49:17 "},"设计模式/04原型模式.html":{"url":"设计模式/04原型模式.html","title":"04原型模式","keywords":"","body":" 原型模式 浅拷贝 深拷贝 原型模式 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象， 说白了就是对象复制。 浅拷贝 对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝 需要实现Cloneable 接口 Object 的 clone() 方法 深拷贝 对基本数据类型进行值传递，对引用数据类型创建一个新的对象，并复制内容 public class ProtoType { public static void main(String[] args) throws CloneNotSupportedException { Person person1 = new Person(new Man(\"John\"), 10); Person person2 = person1.clone(); System.out.println(\"parent1 = \" + person1.toString()); System.out.println(\"parent2 = \" + person2.toString()); person2.setAge(100); person2.setManName(\"abc\"); System.out.println(\"parent1 = \" + person1.toString()); System.out.println(\"parent2 = \" + person2.toString()); } public static class Person implements Cloneable{ Man man; int age = 0; public Person(Man man, int age) { this.man = man; this.age = age; } public void setManName(String manName) { this.man.setName(manName); } public void setAge(int age) { this.age = age; } @Override protected Person clone() throws CloneNotSupportedException { return (Person) super.clone(); } @Override public String toString() { return \"Parent{\" + \"name='\" + man.getName() + '\\'' + \", age=\" + age + '}'; } } public static class Man{ private String name; public Man(String name) { this.name = name; } public void setName(String name) { this.name = name; } public String getName() { return name; } } } 输入结果： parent1 = Parent{name='John', age=10} parent2 = Parent{name='John', age=10} parent1 = Parent{name='abc', age=10} parent2 = Parent{name='abc', age=100} powered by GitbookYoung, 该文件最后修改时间： 2021-05-30 21:14:31 "},"设计模式/05适配器模式.html":{"url":"设计模式/05适配器模式.html","title":"05适配器模式","keywords":"","body":" 适配器模式 1. 类适配器 2. 对象适配器 3. 接口适配器 适配器模式 适配器模式(Adapter Pattern)通过定义一个适配器类作为两个不兼容的接口之间的桥梁，将一个类的接口转化为用户期望的另一个接口，使得两个或多个原本不兼容的接口可以基于适配器类一起工作。 适配器的实现主要分为三种： 类适配器：适配器与适配者之间是继承（或实现）关系 对象适配器：适配器与适配者之间是关联关系 接口适配器：适配器与适配者之间是继承（或实现）关系 1. 类适配器 在需要不改变(或者由于项目原因无法改变)原有接口或者类结构的情况下扩展类的功能以适配不同的接口，可以使用类的适配器模式。类适配器模式通过创建一个继承原有类(需要扩展的类)并实现新接口的适配器类来实现。 主要优点如下： 客户端通过适配器可以透明地调用目标接口。 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。 其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。 考虑下面的场景：我们有一个类(Adaptee),该类有一个adapteeRequest()方法。我们系统调用时，希望调用的是request()方法，这样我们的系统调用和现有的类出现不适配的情况，可以考虑使用适配器模式，新建一个Target接口，该接口有request()接口方法，然后定义适配器类ClassAdapter，该适配器类实现Target接口并继承Adaptee类，在ClassAdapter类的request()方法的实现中调用Adaptee的adapteeRequest()方法即可实现适配，详细的代码如下： /** * 被适配者 * * @author Young * @Date 2021-05-31 21:26 */ public class Adaptee { public void adapteeRequest() { System.out.println(\"被适配者的方法\"); } } /** * 目标接口 * * @author Young * @Date 2021-05-31 21:26 */ public interface Target { /** * 请求接口 */ void request(); } /** * 类适配器 * 怎么才可以在目标接口中的 request() 调用 Adaptee 的 adapteeRequest() 方法呢？ * 如果直接实现 Target 是不行的 * 如果通过一个适配器类，实现 Target 接口，同时继承了 Adaptee 类，然后在实现的 request() 方法中调用父类的 adapteeRequest() 即可实现 */ public class ClassAdapter extends Adaptee implements Target { @Override public void request() { super.adapteeRequest(); } } /** * 测试类 * * @author Young * @Date 2021-05-31 21:28 */ public class AdapterTest { public static void main(String[] args) { Target adapterTarget = new ClassAdapter(); adapterTarget.request(); } } //输出 concreteTarget目标方法 被适配者的方法 2. 对象适配器 对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成，这里稍微修改一下 Adapter 类即可将转变为对象适配器 /** * 对象适配器 * * @author Young * @Date 2021-05-31 21:30 */ public class ObjectAdapter implements Target{ /** * 适配者是对象适配器的一个属性 */ private static final Adaptee ADAPTEE = new Adaptee(); @Override public void request() { ADAPTEE.adapteeRequest(); } } 3. 接口适配器 接口适配器的场景是：当某一个接口的方法比较多，而其实现类又不想实现所有的方法，此时可以创建一个抽象的适配器类，该抽象适配器类实现部分接口方法，实现类继承此抽象适配器类从而达到目的 /** * 接口适配器的目标接口 * * @author Young * @Date 2021-05-31 21:38 */ public interface InterfaceAdapterTarget { /** * 请求接口 */ void request(); /** * 不希望实现的类 */ void uselessMethod(); } /** * 抽象适配器类 * * @author Young * @Date 2021-05-31 21:39 */ public abstract class AbstractInterfaceAdapter implements InterfaceAdapterTarget { @Override public void uselessMethod() { System.out.println(\"uselessMethod\"); } } /** * 抽象适配器的适配器类 * * @author Young * @Date 2021-05-31 21:40 */ public class InterfaceAdapter extends AbstractInterfaceAdapter{ @Override public void request() { System.out.println(\"InterfaceAdapter\"); } } /** * 测试类 * * @author Young * @Date 2021-05-31 21:28 */ public class AdapterTest { public static void main(String[] args) { InterfaceAdapterTarget interfaceAdapterTarget = new InterfaceAdapter(); interfaceAdapterTarget.request(); } } powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 21:44:18 "},"设计模式/06桥接模式.html":{"url":"设计模式/06桥接模式.html","title":"06桥接模式","keywords":"","body":" 桥接模式 桥接模式 桥接模式(Bridge Pattern)通过将抽象及其实现解耦，使二者可以根据需求独立变化。桥接模式用于解决在需求多变的情况下使用继承造成类爆炸的问题，扩展起来不够灵活。可以通过桥接模式将抽象部分和实现部分相分离，使其能够独立变化而相互之间的功能不受影响。具体的做法是通过定义一个桥接接口，使得实体类的功能独立于接口实现类，降低他们之间的耦合度。 桥接（Bridge）模式的优点是： 由于抽象与实现分离，所以扩展能力强； 其实现细节对客户透明。 缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。 符合合成/聚合原则 继承虽然是面向对象的三大特性之一，但继承会导致子类与父类有非常紧密的依赖关系，它会限制子类的灵活性和子类的复用性。而使用合成/聚合，也就是使用接口实现的方式，就不存在依赖问题，一个类可以实现多个接口，可以很方便地拓展功能。 桥接模式的典型例子是是JDBC和DriverManager，JDBC在连接数据库时，在各个数据库之间进行切换而不需要修改代码，因为JDBC提供了统一的接口，每个数据库都提供了各自的实现，通过一个叫做数据库驱动的程序来实现桥接即可。其实现如下： /** * 数据库驱动接口 * * @author Young * @Date 2021-06-01 21:16 */ public interface DbDriver { /** * 执行SQL * @param sqlStr */ void execute(String sqlStr); } /** * MySQL驱动 * * @author Young * @Date 2021-06-01 21:17 */ public class MySqlDbDriver implements DbDriver { @Override public void execute(String sqlStr) { System.out.println(String.format(\"I am MySQL: %s\", sqlStr)); } } /** * Oracle * * @author Young * @Date 2021-06-01 21:19 */ public class OracleDbDriver implements DbDriver{ @Override public void execute(String sqlStr) { System.out.println(String.format(\"I am Oracle: %s\", sqlStr)); } } /** * 数据库驱动桥接的桥 * * @author Young * @Date 2021-06-01 21:20 */ public class DbDriverBridge { private DbDriver dbDriver; public void setDbDriver(DbDriver dbDriver) { this.dbDriver = dbDriver; } /** * 执行SQL * * @param sqlStr */ public void execute(String sqlStr) { dbDriver.execute(sqlStr); } } /** * 桥接模式测试类 * * @author Young * @Date 2021-06-01 21:21 */ public class DbDriverBridgeTest { public static void main(String[] args) { DbDriver oracleDriver = new OracleDbDriver(); DbDriver mySqlDriver = new MySqlDbDriver(); DbDriverBridge dbDriverBridge = new DbDriverBridge(); dbDriverBridge.setDbDriver(mySqlDriver); dbDriverBridge.execute(\"MySQL\"); dbDriverBridge.setDbDriver(oracleDriver); dbDriverBridge.execute(\"Oracle\"); } } 输出： I am MySQL: MySQL I am Oracle: Oracle powered by GitbookYoung, 该文件最后修改时间： 2021-06-01 21:29:28 "},"设计模式/07过滤器模式.html":{"url":"设计模式/07过滤器模式.html","title":"07过滤器模式","keywords":"","body":" 过滤器模式 过滤器模式 过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。 其实就是定义多个过滤器来筛选出符合条件的对象，过滤器和具体的业务逻辑是解耦的 /** * 首先新建一个Person，代表班级里每个人物，同时，设置姓名和性别两个属性。 * 人物对象 * * @author Young * @Date 2021-06-02 21:20 */ public class Person { /** * 姓名 */ private String name; /** * 性别 */ private String gender; public Person(String name, String gender) { this.name = name; this.gender = gender; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", gender='\" + gender + '\\'' + '}'; } } import java.util.List; /** * 过滤器接口 * * @author Young * @Date 2021-06-02 21:21 */ public interface Filter { /** * 过滤方法 * * @param persons * @return */ List filter(List persons); } /** * 女生过滤器 * * @author Young * @Date 2021-06-02 21:23 */ public class GirlFilter implements Filter { @Override public List filter(List persons) { return persons.stream().filter(person -> \"女\".equals(person.getGender()) ).collect(Collectors.toList()); } } /** * 男生过滤器 * * @author Young * @Date 2021-06-02 21:24 */ public class BoyFilter implements Filter{ @Override public List filter(List persons) { return persons.stream().filter(person -> \"男\".equals(person.getGender()) ).collect(Collectors.toList()); } } /** * 过滤器测试 * * @author Young * @Date 2021-06-02 21:25 */ public class FilterTest { public static void main(String[] args) { List persons = new ArrayList<>(15); for (int i = 0; i System.out.println(person.toString())); } } 结果: Person{name='0', gender='男'} Person{name='1', gender='男'} Person{name='2', gender='男'} Person{name='3', gender='男'} Person{name='4', gender='男'} powered by GitbookYoung, 该文件最后修改时间： 2021-06-02 21:30:12 "},"设计模式/08组合模式.html":{"url":"设计模式/08组合模式.html","title":"08组合模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:11:15 "},"设计模式/09装饰器模式.html":{"url":"设计模式/09装饰器模式.html","title":"09装饰器模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:11:20 "},"设计模式/10外观模式.html":{"url":"设计模式/10外观模式.html","title":"10外观模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:11:24 "},"设计模式/11享元模式.html":{"url":"设计模式/11享元模式.html","title":"11享元模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:11:27 "},"设计模式/12代理模式.html":{"url":"设计模式/12代理模式.html","title":"12代理模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:11:31 "},"设计模式/13责任链模式.html":{"url":"设计模式/13责任链模式.html","title":"13责任链模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:11:35 "},"设计模式/14命令模式.html":{"url":"设计模式/14命令模式.html","title":"14命令模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:11:39 "},"设计模式/15解释器模式.html":{"url":"设计模式/15解释器模式.html","title":"15解释器模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:11:45 "},"设计模式/16迭代器模式.html":{"url":"设计模式/16迭代器模式.html","title":"16迭代器模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:11:48 "},"设计模式/17中介模式.html":{"url":"设计模式/17中介模式.html","title":"17中介模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:11:52 "},"设计模式/18备忘录模式.html":{"url":"设计模式/18备忘录模式.html","title":"18备忘录模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:11:56 "},"设计模式/19观察者模式.html":{"url":"设计模式/19观察者模式.html","title":"19观察者模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:12:31 "},"设计模式/20状态模式.html":{"url":"设计模式/20状态模式.html","title":"20状态模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:12:36 "},"设计模式/21策略模式.html":{"url":"设计模式/21策略模式.html","title":"21策略模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:12:40 "},"设计模式/22模板方法.html":{"url":"设计模式/22模板方法.html","title":"22模板方法","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:12:44 "},"设计模式/23访问者模式.html":{"url":"设计模式/23访问者模式.html","title":"23访问者模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-05-31 22:12:50 "},"唯一ID/unique_id.html":{"url":"唯一ID/unique_id.html","title":"分布式唯一ID","keywords":"","body":" 分布式唯一ID 1. 背景 2. 概念 2.1 什么是分布式唯一ID 2.2 分布式唯一ID的特性 2.3 单调递增和趋势递增 2.4 设计分布式ID系统需注意的点 2.5 分布式ID系统的难点 3. 分布式ID生成方案 3.1 UUID 3.1.1 UUID概念 3.1.2 UUID优缺点 3.1.3 Java生成UUID 3.2 数据库自增 3.2.1 概念 3.2.2 优缺点 3.2.3 MySQL设置自增的方式 3.3 数据库集群模式 3.3.1 原理 3.3.2 优缺点 3.3.3 MySQL设置起始值和步长的方法 3.4 数据库号段模式 3.4.1 原理 3.4.2 优缺点 3.4.3 实现 3.4.3.1 乐观锁实现 3.4.3.2 悲观锁实现 3.5 Redis/Zookeeper 3.5.1 Redis方式原理 3.5.1.1 强依赖redis方案 3.5.1.2 弱依赖redis方案 3.5.2 优缺点 3.5.3 实现(redis自增模式的实现) 3.6 雪花算法 3.6.1 原理 3.6.2 优缺点 3.6.3 实现 3.7 美团Leaf算法 3.8 百度uid-generator 3.9 TinyId 4 分布式ID生成方案总结 5 参考资料 分布式唯一ID 1. 背景 我们在设计和实现互联网系统时，往往需要使用到唯一ID。唯一ID标识唯一的一条业务请求，如在电商系统中，ID表示系统中唯一的一个订单，支付系统中表示唯一的一条交易请求。在单机应用中，唯一ID的生成是比较简单的，我们只需保证ID在单机上面是唯一的即可；但目前互联网应用多为微服务应用，同时随着业务的逐渐增长，必须对业务进行分库分表，而且业务应用往往是多实例部署的，这就要求ID在多个微服务应用和多个应用实例之间是唯一。目前业界有很多成熟的唯一ID生成方案，下面我们来看下这些分布式唯一的ID生成方案。 2. 概念 2.1 什么是分布式唯一ID 分布式唯一ID, 应该拆开来解释: 唯一ID: 顾名思义, 这个就不用多解释了 分布式: 分布式对应的是单机应用, 单机应用中唯一ID即是唯一ID，而分库分表应用中多实例之间, 各微服务应用之间全局唯一的ID即是分布式式唯一ID 2.2 分布式唯一ID的特性 全局唯一：唯一ID，顾名思义； 高性能：ID生成的性能要高，否则会影响业务系统的性能； 高可用：ID生成服务要是高可用的，否则一旦出现不可用则会影响业务系统的可用性； 递增；尽量保证是递增的，因为业务系统可能需要根据ID进行排序，分为单调递增和趋势递增； 长度：长度尽可能的短； 侵入性小：尽量做到对业务系统无侵入。 此外，根据业务的不同，还可能要存在其他特性： 时间：有的ID中需要包含时间戳； 业务含义：这个要看具体的业务需求。 2.3 单调递增和趋势递增 单调递增：ID是严格递增的，后面的请求ID一定比之前的请求的ID大； 趋势递增：ID的整体趋势是递增的，不过存在后面的请求的ID比之前的请求ID小的情况。比如这样的ID生成方案：考虑这样的一个场景，2个实例的业务应用，实例1缓存0-1000的ID在进程中，实例2缓存1001-2000的ID在进程中，请求1先请求实例2（随机负载均衡），ID为1001，然后1分钟后请求2请求实例1，ID为0，即出现后面的请求的ID比之前的请求的ID小的情况，但是ID分配的整体趋势是递增的。 2.4 设计分布式ID系统需注意的点 时钟回退：如果ID中包含时间戳信息，需考虑时钟回退的场景，如果出现时钟回退则可能出现重复ID； 多线程问题：ID生成往往是在多线程的环境下的，因此需要注意多线程问题； 数据库性能：有些ID生成算法依赖数据库中的记录，需要考虑数据库的性能问题以及多线程引发的数据库锁问题 2.5 分布式ID系统的难点 ID长度尽可能的短：我们的ID大多数是需要在数据库中存储的，越长的ID占用的空间越多；如果使用该ID作为MySQL的主键，主键也是要求尽可能的短的，所以ID长度要尽可能的短。随之而来的问题是，越短的ID，其中包含的信息越少（信息熵越小），冲突的可能性就越大； 多线程问题：多实例之间，同一实例之间的线程都会抢ID，因此必须注意多线程问题，解决方法大部分是加锁，如果线程之间竞争严重，则严重形象性能。 3. 分布式ID生成方案 3.1 UUID 3.1.1 UUID概念 UUID(universally unique identifier)是一串随机的32位长度的数据，每一位是16进制表示，所以总计能够表示2^128的数字 据统计若每纳秒产生1百万个 UUID，要花100亿年才会将所有 UUID 用完 UUID的生成用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字 UUID为16进制的32字节长度，中间以-相连，形式为8-4-4-4-12，所以说长度也可以是36，不过使用时一般不包含-，UUID的形式如下： ef56e7fd-225b-44b8-b96d-4591bde0945b ********-****-M***-N***-************ 上面的以数字M开头的四位表示UUID 版本，目前UUID的规范有5个版本，M可选值为1, 2, 3, 4, 5 ;各个版本的具体介绍如下所示： version 1：0001。基于时间和 MAC 地址。由于使用了 MAC 地址，因此能够确保唯一性，但是同时也暴露了 MAC 地址，私密性不够好。 version 2：0010。DCE 安全的 UUID。该版本在规范中并没有仔细说明，因此并没有具体的实现。 version 3：0011。基于名字空间 (MD5)。用户指定一个名字空间和一个字符串，通过 MD5 散列，生成 UUID。字符串本身需要是唯一的。 version 4：0100。基于随机数。虽然是基于随机数，但是重复的可能性可以忽略不计，因此该版本也是被经常使用的版本。 version 5：0101。基于名字空间 (SHA1)。跟 Version 3 类似，但是散列函数编程了 SHA1。 上面以数字N开头的四个位表示 UUID 变体( variant )，变体是为了能兼容过去的 UUID，以及应对未来的变化，目前已知的变体有如下几种，因为目前正在使用的 UUID 都是 variant1，所以取值只能是 8，9，a，b 中的一个(分别对应1000,1001,1010,1011)。 variant 0：0xxx。为了向后兼容预留。 variant 1：10xx。当前正在使用的。 variant 2：11xx。为早期微软 GUID 预留。 variant 3：111x。为将来扩展预留。目前暂未使用。 3.1.2 UUID优缺点 优点 无需网络，单机即可生成 速度快 生成简单，有内置的函数库可直接实现 没有业务含义，随机性较好，保密性强(业务层保密，有些版本的UUID可泄露IP或者MAC地址) 机器生成，可保证唯一，讲道理不会重复，但是也存在重复的概率(很低) 缺点 没有业务含义，如果ID中需要业务含义则不适用UUID 太长了，32位长度 无序，可读性差 有些版本的UUID可泄露IP或者MAC地址 3.1.3 Java生成UUID Java内置了java.util.UUID类，其中内置了四种版本的UUID生成策略,包括基于时间和MAC地址的、DCE 安全的UUID、基于名字空间(MD5)和基于随机数的: There are four different basic types of UUIDs: time-based, DCE security, name-based, and randomly generated UUIDs. These types have a version value of 1, 2, 3 and 4, respectively. 比较常用的即是基于随机数的UUID生成，下面是Java的使用方法 UUID.randomUUID().toString(); 3.2 数据库自增 3.2.1 概念 使用数据库的id自增策略,比如Mysql的auto_increment 3.2.2 优缺点 优点 ID单调递增，对业务友好，利于分页和排序； 简单，代码中无需设置，只需要在建表时设置主机递增即可； 缺点 强依赖数据库, 性能存在瓶颈 单库时使用方便,分库分表后就难受了 难以扩展 只能主库生成,单点故障了就gg了 数据库语法不同,迁移时需要考虑 容易泄密,比如订单号是递增的,那么可以猜到别人的订单号 3.2.3 MySQL设置自增的方式 只需设置主键自增即可,如下面的建表语句 CREATE TABLE `user` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT 'id', `name` varchar(64) NOT NULL COMMENT '名字', `nick_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '昵称', `create_time` datetime NOT NULL COMMENT '创建时间', `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci; 3.3 数据库集群模式 3.3.1 原理 数据库自增模式生成的唯一ID,当遇到分库分表场景时, ID则无法解决ID重复的问题，而且ID依赖于数据库，无法满足业务系统高并发以及高可用的需求．一种解决方案是使用数据库多主模式,也即数据库集群中每个实例都可以生成ID, 并且设置自增ID的起始值和步长 其原理图如下： 3.3.2 优缺点 优点 解决数据库自增模式下的单点故障问题以及性能问题 设置同样简单,只比数据库自增模式复杂一些 ID趋势自增，在同一数据库中是严格递增的 缺点 不利于后续扩容: 当我们在开始时设置步长为4时,这样每台数据库实例生成的ID如上图所示(图中下面方框中),但是随着业务增长,如果需要水平扩展数据库,即再增加一个数据库实例,这种情况下需将第5台实例的步长设置为5,第5台实例的起始位置要大于前4台实例中ID的最大值(预留部分,防止此段时间前4个实例中ID超过该值), 并且将前4台实例的步长修改为5. 而且还存在停机修改的可能性; 一种解决方案是初始时预留足够的步长,比如初始时有4台实例,但是设置步长可以为8,后续可水平扩展(当然缺点是单个实例ID耗尽速度*2) 强依赖数据库，同样存在性能问题. 如果是水平切分，如根据用户ID分库分表，那么某个分库挂了同样会影响可用性 3.3.3 MySQL设置起始值和步长的方法 实例1: set @@auto_increment_offset = 1; -- 起始值 set @@auto_increment_increment = 6; -- 步长 实例2: set @@auto_increment_offset = 2; -- 起始值 set @@auto_increment_increment = 6; -- 步长 实例3: set @@auto_increment_offset = 3; -- 起始值 set @@auto_increment_increment = 6; -- 步长 实例4: set @@auto_increment_offset = 4; -- 起始值 set @@auto_increment_increment = 6; -- 步长 3.4 数据库号段模式 3.4.1 原理 数据和本地缓存相结合的方式, 每个实例首先从数据库中取出一个ID的生成范围，然后需要使用时采用线程安全的方式从本地缓存的ID范围中取出即可,等实例内缓存的ID耗尽时再从数据库中取出一个ID生成范围 3.4.2 优缺点 优点 弱依赖数据库,每次从数据库中取出一个ID范围,提高了可用性和ID生成的性能. 即使生成ID的数据库挂了,实例中缓存的ID也能撑一段,而这段时间已经足够数据库恢复了(ID数据库和业务数据库是同一个数据库的话,就没用了) ID趋势递增 缺点 实例挂了, 则缓存的号段就丢失了 应用自身需保证线程安全, 可以采用AtomicLong的方式来保证 如果在号段耗尽后再去数据库取新的号段, 如果并发较高, 那么取号段的操作也会出现竞争严重的场景, 导致数据库压力较大, 一种解决方案是采用双buffer的方案, 即当第一个号段buffer1耗尽10%的时候, 开启一个线程取数据库中取号段缓存到另外一个buffer2中, 当第一个buffer1耗尽后能够立即切换到buffer2中; 不够随机, 订单场景不适用, 如果每天中午12点下单, 订单号相减能够大致推断出一天的订单量. 3.4.3 实现 号段模式可以有悲观锁和乐观锁两种实现, 这里我觉得两种方式都可以, 因为该唯一ID的生成方式就说明不会频繁的读写数据库,所以数据库的锁竞争不会很大, 乐观锁和悲观锁方式都可以应该都可以满足需求, 不过使用时还是需要按照具体的业务来设计. 3.4.3.1 乐观锁实现 CREATE TABLE id_generator ( id int(10) NOT NULL, max_id bigint(20) NOT NULL COMMENT '当前最大id', step int(20) NOT NULL COMMENT '号段的步长', biz_type int(20) NOT NULL COMMENT '业务类型', version int(20) NOT NULL COMMENT '版本号', PRIMARY KEY (`id`) ) 实例取ID的步骤: 从数据库中获取当前最大ID, SQL为: select max_id, step, version from id_generator where biz_type = '**'; 实例中设置ID范围范围为[max_id, max_id + step] 更新数据库中记录, SQL为: update table id_generator set max_id = max_id + step +1, version = version + 1 where biz_type = '**' and version = version(第一步中取出的); 如果第三步更新失败, 则说明发生冲突, 从第一步开始重试, 直到第三步成功; 3.4.3.2 悲观锁实现 CREATE TABLE id_generator ( id int(10) NOT NULL, max_id bigint(20) NOT NULL COMMENT '当前最大id', step int(20) NOT NULL COMMENT '号段的步长', biz_type int(20) NOT NULL COMMENT '业务类型', version int(20) NOT NULL COMMENT '版本号', PRIMARY KEY (`id`) ) 实例取ID的步骤: 开启事务; 从数据库中获取当前最大ID, SQL为: select max_id, step from id_generator where biz_type = '**' for update; 实例中设置ID范围范围为[max_id, max_id + step] 更新数据库中记录, SQL为: update table id_generator set max_id = max_id + step +1, version = version + 1 where biz_type = '**'; 提交事务 3.5 Redis/Zookeeper 采用中间件的方式, Redis和Zookeeper都可以实现, 不过Zookeeper我很少使用,这里不再讨论,其原理和Redis方式基本相同 3.5.1 Redis方式原理 3.5.1.1 强依赖redis方案 利用redis的 incr命令实现ID的原子性自增。 127.0.0.1:6379> set seq_id 1 // 初始化自增ID为1 OK 127.0.0.1:6379> incr seq_id // 增加1，并返回递增后的数值 (integer) 2 3.5.1.2 弱依赖redis方案 原理和数据库号段模式类似, redis中自增的是号段的起始值, 实例内缓存一个ID范围, 这里不再赘述. 3.5.2 优缺点 优点 实现简单 性能比数据库自增ID的方式要高 缺点 依赖redis, 系统需要引入中间件,增加了运维等成本; redis需考虑持久化, redis有两种持久化方式RDB和AOF. RDB会定时打一个快照进行持久化，假如连续自增但redis没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况; AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致Redis重启恢复的数据时间过长。 3.5.3 实现(redis自增模式的实现) 先设置RedisTemplate： @Bean public RedisTemplate getDefaultRedisTemplate(RedisConnectionFactory cf, RedisSerializer rs) { RedisTemplate redisTemplate = new RedisTemplate(); redisTemplate.setConnectionFactory(cf); redisTemplate.setDefaultSerializer(rs); redisTemplate.setKeySerializer(new StringRedisSerializer()); return redisTemplate; } 接下来实现ID生成逻辑： public long generate(String key,int increment) { RedisAtomicLong counter = new RedisAtomicLong(key, mRedisTemp.getConnectionFactory()); return counter.addAndGet(increment); } 3.6 雪花算法 Twitter公司开源的一种算法, 全局唯一并且趋势递增 3.6.1 原理 雪花算法生成的是8字节64bit长度的数字(long类型), 能够保证趋势递增的ID生成, 而且生成效率极高 雪花算法组成 第1位: 占用1bit，其值始终是0，保证生成的ID是正数; 第2- 42位: 时间戳, 占用41bit，精确到毫秒，总共可以容纳约69年的时间; 第43-52位: 工作机器id, 占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点; 第53-64位:序列号,占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。 SnowFlake算法在同一毫秒内最多可以生成的ID数量为: 1024 * 4096 = 4194304 3.6.2 优缺点 优点 基于时间戳，可以保证基本有序递增 不依赖第三方的库或者中间件, 在实例上生成, 可以保证高可用 生成效率极高, 满足高性能的要求 缺点 依赖机器时间, 如果发生时钟回退, ID可能重复 3.6.3 实现 /** * 雪花算法 * * @author Young * @Date 2021-05-22 17:04 */ public class SnowflakeIdGenerator { /** * 开始时间截 (这个用自己业务系统上线的时间) */ private static final long START_TIMESTAMP = 1575365018000L; /** * 机器id所占的位数 */ private static final long WORKER_ID_BITS_LENGTH = 10L; /** * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private static final long MAX_WORKER_ID = -1L ^ (-1L MAX_WORKER_ID || workerId 3.7 美团Leaf算法 推荐原系统的设计和开发者写的Leaf——美团点评分布式ID生成系统, 已经非常详细了, 小的就不再班门弄斧了 另外这篇也值得一看 Leaf：美团的分布式唯一ID方案深入剖析 美团Leaf算法有两种模式: segment模式: 即数据库号段模式, 优缺点在上文已经讨论过了; snowflake模式: 其主要有以下几点优化 解决时钟回退问题: 周期性上传实例时间戳到zookeeper中, 生成ID时获取的时间戳会与Zookeeper的时间戳比较, 但是并没有完全解决问题, 如果时钟回退超过5ms还是会抛出异常; 弱依赖zookeeper, 采用zookeeper持久化节点信息(即雪花算法中的实例节点信息), 但是引入zookeepery也是需要成本的 3.8 百度uid-generator UidGenerator UidGenerator：百度开源的分布式ID服务（解决了时钟回拨问题） 百度开源分布式id生成器uid-generator源码剖析 百度uid-generator也是类snowflake算法, 其主要特点有: 调整雪花算法的位数, 机器节点数增大 弱依赖时间戳, 采用当前时间(秒)和系统上线时间的差值 加入缓存机制, 更高的性能 实例信息从数据库中获取, 每次重启实例序号 + 1 3.9 TinyId TinyId 滴滴开源的Tinyid如何每天生成亿级别的ID？ Tinyid是用Java开发的一款分布式id生成系统，基于数据库号段算法实现, 简单来说是数据库中保存了可用的id号段，tinyid会将可用号段加载到内存中，之后生成id会直接内存中产生。 可用号段在第一次获取id时加载，如当前号段使用达到一定量时，会异步加载下一可用号段，保证内存中始终有可用号段。(如可用号段1~1000被加载到内存，则获取id时，会从1开始递增获取，当使用到一定百分比时，如20%(默认)，即200时，会异步加载下一可用号段到内存，假设新加载的号段是1001~2000,则此时内存中可用号段为200~1000,1001~2000)，当id递增到1000时，当前号段使用完毕，下一号段会替换为当前号段。依次类推。 TinyId的主要特点有: 采用数据库号段模式 使用了双缓存的逻辑 多DB支持(数据库集群模式) 4 分布式ID生成方案总结 分布式ID生成方案大致分为2种, 一是基于数据库或者redis的生成方案, 二是类雪花算法生成方案 雪花算法生成方案中, 存在时钟回退问题, 时钟回退的问题可以使用记录下上次生成的时间戳(引入数据库或者中间件), 当生成ID时对比下当前时间和记录的时间戳, 如果发生时钟回退,那么抛出异常或者将阻塞等待. 数据库或者redis的生成方案中, 存在难以扩展和数据库性能问题, 衍生出数据库集群模式的方案和号段模式的方案, 号段模式为了防止耗尽时的高并发, 一般采用双缓存的解决方案. 5 参考资料 分布式ID之UUID适合做分布式ID吗 UUID/GUID介绍、生成规则及生成代码 分布式唯一 ID 生成方案，有点全！ 分布式唯一ID生成方案 一口气说出9种分布式ID生成方式，面试官有点懵了 这可能是讲雪花算法最全的文章 分布式ID神器之雪花算法简介 Leaf——美团点评分布式ID生成系统 UidGenerator UidGenerator：百度开源的分布式ID服务（解决了时钟回拨问题） 百度开源分布式id生成器uid-generator源码剖析 TinyId 滴滴开源的Tinyid如何每天生成亿级别的ID？ powered by GitbookYoung, 该文件最后修改时间： 2021-05-22 18:51:23 "},"工具使用/idea常用操作.html":{"url":"工具使用/idea常用操作.html","title":"IDEA常用操作","keywords":"","body":" IDEA常用操作 1. 设置类 1.1 设置Ctrl+滚轮 放大/缩小 编辑窗口 2. 快捷键 2.1 编辑 2.2 导航 2.3 搜索 2.4 重构 2.5 Debug 2.6 Git 2.7 通用 IDEA常用操作 1. 设置类 1.1 设置Ctrl+滚轮 放大/缩小 编辑窗口 2. 快捷键 如何查看自己的KeyMap? 下文整理的是windows/linux的格式的快捷键 2.1 编辑 Ctrl + P : 查看方法参数 Ctrl + Q : 查看方法的JavaDoc Alt + Insert : 插入代码 Ctrl + O : 插入重写方法 Ctrl + I : 实现方法 Ctrl + Alt + T : Surround With: 包括代码块 Crl + / : 单行注释 or 取消单行注释 Ctrl + Shift + / : 多行注释 or 取消多行注释 Ctrl + Alt + L : 格式化代码 Ctrl + Alt + O : 自动去除多余的import Ctrl + Alt + I : 自动缩进 Tab : 向后缩进1个制表符 Shift + Tab : 向前缩进1个制表符 Ctrl + X : 剪切当前行 Ctrl + C : 复制当前行 Ctrl + V : 粘贴 Ctrl + Shift + V : 复制的内容的历史记录 Ctrl + D : 复制当前行到下一行 Ctrl + Y : 删除当前行 Ctrl + Shift + [ : 选择当前位置到上一个{的代码 Ctrl + Shift + ] : 选择当前位置到下一个}的代码 Ctrl + Shift + U : 大小写转换 Ctrl + Delete : 删除当前光标后的一个单词、空格等 Ctrl + Backspace : 删除当前光标前的一个单词、空格等 Ctrl + '+' : 展开当前光标所在代码块 Ctrl + '-' : 关闭当前光标所在代码块 Ctrl + Shift + '+' : 展开所有代码块 Ctrl + Shift + '-' : 关闭所有代码块 Ctrl + F4 : 关闭所有编辑的文件 2.2 导航 Esc : 从tool windows回到编辑区 Ctrl + E : 弹窗显示最近打开的文件 Ctrl + Alt + : 后退 or 前进 光标最近移动位置 Ctrl + Alt + B : 进入接口的实现方法中 Ctrl + B or Ctrl + 左键 : 进入方法中，如果是接口则跳到接口上面 Ctrl + U : 跳到父类或者父类的方法 Ctrl + [ or ] : 代码块前后 Ctrl + F12 : 显示类的结构 2.3 搜索 shift + shift : 任意搜索 Ctrl + F : 在当前文件中搜索 Ctrl + R : 替换 Alt + F7 : 查看当前方法/类/变量在何处使用了 2.4 重构 Shift + F6 : 重命名类、方法、变量、常量 Ctrl + F6 : 调整方法参数 Ctrl + Alt + M : 将选中的代码块提取为一个方法 Ctrl + Alt + C : 将选中的代码提取为一个常量 Ctrl + Alt + F : 将选中的代码提取为一个全局变量 Ctrl + Alt + V : 将选中的代码提取为一个局部变量 Ctrl + Alt + P : 将选中的代码提取为方法的参数 2.5 Debug F7 : 进入方法 F8 : 单步调试 2.6 Git Ctrl + T : 提交界面 Ctrl + K : pull Ctrl + Shift + K : push 2.7 通用 Ctrl + Tab : 切换IDEA中的窗口 powered by GitbookYoung, 该文件最后修改时间： 2021-05-27 23:03:42 "}}