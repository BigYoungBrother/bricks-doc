{"./":{"url":"./","title":"Introduction","keywords":"","body":"前言 自己所学习的一些开发知识，希望都能够记录下来，在搬砖界留下点痕迹... 使用Markdown语法编写，可直接在gitee中查看，也可以下载下来 github地址 gitpage地址 下载到本地的查看方法： markdown编辑器，推荐Typora和vs code + markdown all in one插件 gitbook 使用到的代码: java-notes gitbook使用方法： 运行gitbook服务 安装node 下载gitbook包npm install -g gitbook-cli 在本项目根目录下执行gitbook serve --port 23333后在浏览器中输入127.0.0.1:23333后即可 直接查看gitbook生成的html文件 在本项目根目录下_book文件夹中有对应的html文件 目录 powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 13:59:59 "},"设计模式/readme.html":{"url":"设计模式/readme.html","title":"设计模式","keywords":"","body":"GOF23设计模式 powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/00概述.html":{"url":"设计模式/00概述.html","title":"00设计模式概述","keywords":"","body":" 简介 设计模式的七种原则 单一职责原则 开闭原则 里氏替换原则 依赖倒置原则 接口隔离原则 迪米特法则 合成/聚合原则 23种设计模式的分类 简介 设计模式(Design Pattern)是经过高度抽象化的在编程中可以被反复使用的代码设计经验的总结 简单说设计模式就是经过实践验证的良好的编码经验 这里说的设计模式指的是GOF23，GOF指： 在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版> 了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：> 设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。 设计模式的七种原则 单一职责原则 就是一个类只有一个职责。 开闭原则 软件中的对象(类、模块、函数等)对扩展开放，对修改关闭；这意味着一个实体在不改变其源代码的前提下改变其行为。 里氏替换原则 里氏替换原则是对开闭原则的补充，规定了在任意父类可以出现的地方，其子类一定可以出现。一般面向对象的编程语言都支持该特性。 依赖倒置原则 程序依赖于抽象类，而不是具体的实现类，即面向接口编程。 接口隔离原则 不同的功能应该定义在不同的接口中，其实就是单一职责原则 迪米特法则 又名最少知道原则，就是一个实体应当尽量少地与其他实体之间发生相互作用，其核心思想在于降低模块之间的耦合度 合成/聚合原则 在新的对象中引入其他对象以达到类的功能服用和扩展的目的 23种设计模式的分类 设计模式按照其功能和使用场景可以分为3大类：创建型、结构型和行为型 类型 说明 设计模式 创建型 提供多种优雅创建对象的方法 简单工厂(不是23种之一但应用广泛) 工厂方法 抽象工厂 单例模式 建造者模式 原型模式 结构型 通过类和接口之间的继承和引用实现创建复杂结构对象 适配器模式 桥接模式 过滤器模式 组合模式 装饰器模式 外观模式 享元模式 代理模式 行为型 通过类之间不同的通信方式实现不同的行为方式 责任链模式 命令模式 解释器模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 模板模式 访问者模式 powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/01工厂模式.html":{"url":"设计模式/01工厂模式.html","title":"01工厂模式","keywords":"","body":" 工厂模式 1. 简单工厂 1.1 简单工厂实现 1.2 简单工厂的优缺点 2. 工厂方法 2.2.1 工厂方法实现 2.2.2 工厂方法优缺点 2.3 抽象工厂 2.3.2 抽象工厂优缺点 2.4 三种工厂方法的适用场景 工厂模式 工厂模式提供了一种简单、快速、高效且安全地创建对象的方式， 工厂方法不直接创建对象，而将创建对象的过程放到对应的工厂类中实现， 如果后续需要修改对象， 只需更改工厂即可。 工厂模式可以分为三种： 简单工厂 工厂方法 抽象工厂 1. 简单工厂 1.1 简单工厂实现 在此以手机为例说明工厂方法，手机的品牌有华为、 小米、 VIVO、 OPPO等。 我们的需求是：根据客户传入的手机品牌名字来实例化一个手机对象。 如果是常规的写法， 我们需要根据传入的手机品牌名字来进行判断(if - else)，这样的就会导致代码中存在大量的if-else分支， 这样很不利于维护。 简单工厂的设计思想即是将实例化对象的过程放到工厂类中， 当我们需要对象时直接调用工厂类即可获取对象。 看下UML类图 1. 手机接口 /** * 手机接口 * * @author Young * @Date 2021-03-27 22:13 */ public interface Phone { /** * 返回手机名 * * @return */ String getName(); } 2. 各个手机对象， 包含华为、 小米、 VIVO、 OPPO /** * 华为手机 * * @author Young * @Date 2021-03-27 22:13 */ public class HuaWeiPhoneImpl implements Phone { @Override public String getName() { return \"我是华为手机\"; } } /** * 小米手机 * * @author Young * @Date 2021-03-27 22:09 */ public class XiaoMiPhoneImpl implements Phone { @Override public String getName() { return \"我是小米手机\"; } } /** * Vivo手机 * * @author Young * @Date 2021-03-27 22:11 */ public class VivoPhoneImpl implements Phone { @Override public String getName() { return \"我是VIVO手机\"; } } /** * OPPO手机 * * @author Young * @Date 2021-03-27 22:23 */ public class OppoPhoneImpl implements Phone { @Override public String getName() { return \"我是OPPO手机\"; } } 3. 手机工厂 /** * 手机工厂--简单工厂 * * @author Young * @Date 2021-03-27 22:25 */ public class PhoneSimpleFactory { public Phone getPhone(String phoneName) { switch (phoneName) { case \"VIVO\": return new VivoPhoneImpl(); case \"XiaoMi\": return new XiaoMiPhoneImpl(); case \"HuaWei\": return new HuaWeiPhoneImpl(); case \"OPPO\": return new OppoPhoneImpl(); default: return null; } } } 4. 简单工厂的使用 /** * 简单工厂测试 * * @author Young * @Date 2021-03-27 22:30 */ public class SimpleFactoryTest { public static void main(String[] args) { PhoneSimpleFactory phoneSimpleFactory = new PhoneSimpleFactory(); Phone phone = phoneSimpleFactory.getPhone(\"HuaWei\"); if (Objects.nonNull(phone)) { System.out.println(\"PhoneName: \" + phone.getName()); } } } 1.2 简单工厂的优缺点 优点 使用简单，只有一个工厂类，这个工厂能够生产多种产品 缺点 当产品较多时，工厂类会变得很庞大，而且任何一个产品的修改都会修改到该工厂类， 违反了单一职责原则； 当新增一个产品时，需要在工厂类中新增一个分支，违反了开闭原则。 2. 工厂方法 上文说简单工厂方法，当产品较多时，工厂类会变得很庞大，而且新增产品时，工厂类需要新增分支，违反单一职责原则和开闭原则。而工厂模式可以解决该问题。 2.2.1 工厂方法实现 还是以手机为例，与简单工厂不同， 工厂方法要求每个手机都要有自己的工厂类，当我们需要手机对象时，直接从对应的工厂中取即可。在手机的例子中，HuaWeiPhone有其对应的HuaWeiPhoneFactory工厂类， XiaoMiPhone有其对应的XiaoMiPhoneFactory工厂类，UML类图如下： 1. 手机接口和各手机对象的定义见简单工厂 2. 工厂接口 /** * 手机工厂接口 * * @author Young * @Date 2021-03-27 22:35 */ public interface PhoneFactory { /** * 返回手机对象 * * @return */ Phone getPhone(); } 3. 各工厂类 /** * 华为手机工厂 * @author Young * @Date 2021-03-27 22:34 */ public class HuaWeiPhoneFactory implements PhoneFactory{ @Override public Phone getPhone(){ return new HuaWeiPhoneImpl(); } } /** * 小米手机工厂 * * @author Young * @Date 2021-03-27 22:35 */ public class XiaoMiPhoneFactory implements PhoneFactory { @Override public Phone getPhone() { return new XiaoMiPhoneImpl(); } } /** * OPPO手机工厂 * * @author Young * @Date 2021-03-27 22:38 */ public class OppoPhoneFactory implements PhoneFactory { @Override public Phone getPhone() { return new OppoPhoneImpl(); } } /** * VIVO手机工厂 * * @author Young * @Date 2021-03-27 22:40 */ public class VivoPhoneFactory implements PhoneFactory { @Override public Phone getPhone() { return new VivoPhoneImpl(); } } 4. 工厂方法使用 /** * 工厂方法测试类 * * @author Young * @Date 2021-03-27 22:40 */ public class FactoryPatternTest { public static void main(String[] args) { // 从华为手机工厂中取华为手机 PhoneFactory huaWeiPhoneFactory = new HuaWeiPhoneFactory(); Phone huaWeiPhone = huaWeiPhoneFactory.getPhone(); System.out.println(huaWeiPhone.getName()); // 从小米手机工厂中取小米手机 PhoneFactory xiaoMiPhoneFactory = new XiaoMiPhoneFactory(); Phone xiaoMiPhone = xiaoMiPhoneFactory.getPhone(); System.out.println(xiaoMiPhone.getName()); } } 2.2.2 工厂方法优缺点 优点 工厂类只负责生产对应的产品，符合单一职责原则； 新增产品时，需要新增一个工厂类，符合开闭原则。 缺点 使用时需要知道具体的工厂类 2.3 抽象工厂 抽象工厂模式在工厂模式上添加了一个创建不同工厂的抽象接口(抽象类或者接口)，该接口可叫做超级工厂。在使用时， 首先根据不同的工厂接口创建不同的工厂对象，然后根据不同的工厂对象创建不同的对象。 可以将工厂模式理解为针对一个产品维度进行分类，比如简单工厂和工厂方法中的手机对象。而抽象工厂模式针对的是多个产品维度分类，比如华为即生产手机也生产电脑。 在同一个公司有多个维度的产品时，如果使用工厂模式，则势必会存在多个独立的工厂，即华为手机工厂和华为电脑工厂，而这样的设计和实际的物理世界是不对称的，这个问题可以通过抽象工厂方法来实现。可以将抽象工厂类比作公司(华为、小米)，将抽象工厂创建出来的工厂类比作产品(手机和电脑)，生产产品时根据抽象工厂进行生产， 看下UML类图： 1. 手机接口和其实现类见上文 2. 电脑接口和其实现类 /** * 电脑接口 * * @author Young * @Date 2021-03-28 13:13 */ public interface Computer { /** * 返回电脑 * * @return */ String getName(); } /** * 华为电脑 * @author Young * @Date 2021-03-28 13:18 */ public class HuaWeiComputerImpl implements Computer { @Override public String getName() { return \"我是华为笔记本电脑\"; } } /** * 小米笔记本 * * @author Young * @Date 2021-03-28 13:19 */ public class XiaoMiComputerImpl implements Computer { @Override public String getName() { return \"我是小米笔记本\"; } } 3. 抽象工厂接口 /** * 电子产品工厂(超级工厂) * * @author Young * @Date 2021-03-28 13:12 */ public interface ElectronicGoodsFactory { /** * 制造手机 * * @param phoneName * @return */ Phone getPhone(String phoneName); /** * 制造电脑 * * @param computerName * @return */ Computer getComputer(String computerName); } 4. 手机简单工厂 /** * 手机工厂 * * @author Young * @Date 2021-03-28 13:15 */ public class PhoneFactory implements ElectronicGoodsFactory { @Override public Phone getPhone(String phoneName) { switch (phoneName) { case \"VIVO\": return new VivoPhoneImpl(); case \"XiaoMi\": return new XiaoMiPhoneImpl(); case \"HuaWei\": return new HuaWeiPhoneImpl(); case \"OPPO\": return new OppoPhoneImpl(); default: return null; } } @Override public Computer getComputer(String computerName) { return null; } } 5. 电脑简单工厂 /** * 电脑工厂 * * @author Young * @Date 2021-03-28 13:17 */ public class ComputerFactory implements ElectronicGoodsFactory { @Override public Phone getPhone(String phoneName) { return null; } @Override public Computer getComputer(String computerName) { switch (computerName) { case \"HuaWei\": return new HuaWeiComputerImpl(); case \"XiaoMi\": return new XiaoMiComputerImpl(); default: return null; } } } 6. 抽象工厂测试类 /** * 抽象工厂测试类 * @author Young * @Date 2021-03-28 13:22 */ public class AbstractFactoryTest { public static void main(String[] args) { // 制造华为电脑 ElectronicGoodsFactory computerFactory = new ComputerFactory(); Computer huaWeiComputer = computerFactory.getComputer(\"HuaWei\"); System.out.println(huaWeiComputer.getName()); // 制造华为手机 ElectronicGoodsFactory phoneFactory = new PhoneFactory(); Phone huaWeiPhone = phoneFactory.getPhone(\"HuaWei\"); System.out.println(huaWeiPhone.getName()); } } 2.3.2 抽象工厂优缺点 优点 适用于不同维度的产品(不仅有手机，还有电脑)，可横向扩展产品以及产品种类 缺点 如果抽象工厂接口需要新增功能，则会影响所有的工厂实现类 2.4 三种工厂方法的适用场景 简单工厂: 用来生产同一等级结构中的任意产品。（不支持拓展增加产品） 工厂方法: 用来生产同一等级结构中的固定产品。（支持拓展增加产品） 抽象工厂: 用来生产不同产品族的全部产品。（支持拓展增加产品；支持增加产品族） powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/02单例模式.html":{"url":"设计模式/02单例模式.html","title":"02单例模式","keywords":"","body":" 单例模式 1. 饿汉式 2. 懒汉式(线程不安全) 3. 懒汉式(线程安全) 4. 双重校验锁 5. 静态内部类 6. 枚举类 6.1 破坏单例模式的几种方法 6.2 枚举实现的单例 7. 破坏单例模式的方法及解决办法 8. 参考资料 单例模式 单例模式的设计保证了一个类在整个系统中同一时刻只有一个实例存在，主要被用于一个全局类的对象在多个地方被使用并且对象的状态是全局变化的场景下。单例模式首先通过将类的实例化方法私有化来防止程序通过其他方式创建该类的实例， 然后通过提供一个全局唯一获取该类的实例的方法帮助用户获取类的实例，用户只需要也只能通过该方法获取类的实例。 单例模式的实现和简单，每次在获取对象前首先判断系统是否已经有这个单例对象，有则返回，没有则创建。 单例模式的写法主要包含： 饿汉式 懒汉式(线程不安全) 懒汉式(线程安全) 懒汉式(双重校验锁) 静态内部类 枚举类 1. 饿汉式 饿汉式指在类中直接定义全局的静态对象的实例并初始化，然后提供一个方法获取该实例对象。 优点是实现简单，但是如果该实例对象没有使用，该实例对象仍然会被实例化，浪费资源。 代码如下： /** * 单例模式 -- 饿汉式 * * @author Young * @Date 2021-05-24 20:53 */ public class HungerSingleton { private static final HungerSingleton HUNGER_SINGLETON = new HungerSingleton(); private HungerSingleton() { } public static HungerSingleton getHungerSingleton() { return HUNGER_SINGLETON; } } 2. 懒汉式(线程不安全) 懒汉式的\"懒\"记忆为懒加载，即在使用时才实例化 懒汉式是说在对象使用到的时候才会实例化，其实现也非常简单，代码如下： public class LazySingleton { private static LazySingleton LAZY_SINGLETON = null; private LazySingleton() { } /** * 线程不安全的实现方式 * * @return */ public static LazySingleton getLazySingletonUnsafe() { if (Objects.isNull(LAZY_SINGLETON)) { LAZY_SINGLETON = new LazySingleton(); } return LAZY_SINGLETON; } } 为什么说该方式是线程不安全的呢？ 假设我们有两个线程同时调用getLazySingletonUnsafe()方法，且拿到的LAZY_SINGLETON都是null，那么每个线程都会执行一次LAZY_SINGLETON = new LazySingleton();，这种情况将导致LAZY_SINGLETON被实例化2次，导致资源的浪费 3. 懒汉式(线程安全) 上一节中的方法是线程不全的，那么怎么才能做到线程安全呢？答案很简单，在方法上面加锁就可以了，实现也很简单，代码如下： public class LazySingleton { private static LazySingleton LAZY_SINGLETON = null; private LazySingleton() { } /** * 线程不安全的实现方式 * * @return */ public static synchronized LazySingleton getLazySingletonSafe() { if (Objects.isNull(LAZY_SINGLETON)) { LAZY_SINGLETON = new LazySingleton(); } return LAZY_SINGLETON; } } 但是该方法的缺点也很明显，每次调用getLazySingletonSafe()方法时都会加锁，我们知道加锁是比较耗时的，所以这种方法存在着性能问题的。 4. 双重校验锁 既然说加锁的操作存在性能问题，所以我们怎么做才能做到 每次调用getLazySingletonSafe()时不必加锁； 不必加锁时怎么保证线程安全的。 我们加锁的初衷是因为当LAZY_SINGLETON == null时需要防止实例对象被多次实例化，也就是当LAZY_SINGLETON == null时才需要加锁，所以可以做一下判断，当LAZY_SINGLETON == null时才加锁。所以我们可以这么写： /** * 单例模式 -- 双重校验锁 * * @author Young * @Date 2021-05-24 22:02 */ public class DoubleCheckSingleton { private volatile static DoubleCheckSingleton DOUBLE_CHECK_SINGLETON = null; private DoubleCheckSingleton() { } /** * 线程安全的实现方式（仍然线程不安全） * * @return */ public static DoubleCheckSingleton getDoubleCheckSingletonSafe() { if (Objects.isNull(DOUBLE_CHECK_SINGLETON == null)) { // 第一步， 当 DOUBLE_CHECK_SINGLETON为null时才对实例化对象的部分进行加锁 synchronized (DoubleCheckSingleton.class) { // 第二步， 一个时刻只有一个线程能到达这里 if (Objects.isNull(DOUBLE_CHECK_SINGLETON)) { // 第三步，这里还需要进一步判断， 如果线程1和线程2都执行到第一步，然后抢占锁，假设线程1抢到锁，成功进入synchronized代码块并实例化对象。然后实例2进入synchronized代码块中，这时DOUBLE_CHECK_SINGLETON已经不是null，如果不进行判断，则对象又会被实例化一次，所以在synchronized代码块中必须进行第二次的实例对象是否为空的判断 DOUBLE_CHECK_SINGLETON = new DoubleCheckSingleton(); } } } return DOUBLE_CHECK_SINGLETON; } } 为什么使用双重校验锁呢？ 第一次校验：也就是第一个if，这个是为了代码提高代码执行效率，由于单例模式只要一次创建实例即可，所以当创建了一个实例之后，再次调用getDoubleCheckSingletonSafe()方法就不必要进入同步代码块，不用竞争锁。直接返回前面创建的实例即可。 第二次校验：也就是第二个if，这个校验是防止二次创建实例，假如有一种情况，当DOUBLE_CHECK_SINGLETON还未被创建时，线程1调用getDoubleCheckSingletonSafe()方法，由于第一次判断if，此时线程1准备继续执行，但是由于资源被线程2抢占了，此时线程2调用getDoubleCheckSingletonSafe()方法，同样的，由于DOUBLE_CHECK_SINGLETON并没有实例化，线程2同样可以通过第一个if判断，然后继续往下执行进入同步代码块，第二个if也通过，然后线程2创建了一个实例LAZY_SINGLETON。此时线程2完成任务，资源又回到线程1，线程1此时也进入同步代码块，如果没有这个第二个if，那么，线程1就也会创建一个singleton实例，那么，就会出现创建多个实例的情况，但是加上第二个if，就可以完全避免这个多线程导致多次创建实例的问题。 为什么使用volatile关键字？ volatile关键字可以防止jvm指令重排优化 因为 DOUBLE_CHECK_SINGLETON = new DoubleCheckSingleton() 这句话可以分为三步： 为 DOUBLE_CHECK_SINGLETON 分配内存空间； 初始化DOUBLE_CHECK_SINGLETON; 将DOUBLE_CHECK_SINGLETON指向分配的内存空间。 但是由于JVM具有指令重排的特性，执行顺序有可能变成 1-3-2。 指令重排在单线程下不会出现问题，但是在多线程下会导致一个线程获得一个未初始化的实例。例如：线程1执行了1和3，此时线程2调用 getDoubleCheckSingletonSafe() 后发现DOUBLE_CHECK_SINGLETON不为空，因此返回DOUBLE_CHECK_SINGLETON， 但是此时的DOUBLE_CHECK_SINGLETON还没有被初始化。使用 volatile 会禁止JVM指令重排，从而保证在多线程下也能正常执行。 也即是： Time Thread A Thread B T1 检查到DOUBLE_CHECK_SINGLETON为空 T2 获取锁 T3 再次检查到DOUBLE_CHECK_SINGLETON为空 T4 为DOUBLE_CHECK_SINGLETON分配内存空间 T5 将DOUBLE_CHECK_SINGLETON指向内存空间 T6 检查到DOUBLE_CHECK_SINGLETON不为空 T7 访问DOUBLE_CHECK_SINGLETON（此时对象还未完成初始化） T8 初始化DOUBLE_CHECK_SINGLETON 在这种情况下，T7时刻线程B对DOUBLE_CHECK_SINGLETON的访问，访问的是一个初始化未完成的对象。 保证线程可见性 Java内存模型中，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 要解决这个问题，就需要把变量声明为 volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。 5. 静态内部类 静态内部类通过在类中定义一个静态内部类，将实例对象实例的定义和初始化放在内部类中完成，我们在获取对象时要通过静态内部类调用其单例对象。之所以这样设计，时因为类的静态内部类在JVM中是唯一的，这很好地保证了单例对象的唯一性。 静态内部类单例模式也称单例持有者模式，实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由static修饰，保证只被实例化一次，并且严格保证实例化顺序。 代码如下： /** * 单例模式 -- 静态内部类 * * @author Young * @Date 2021-05-25 20:48 */ public class StaticInnerClassSingleton { private static class SingletonHolder{ private static final StaticInnerClassSingleton STATIC_INNER_CLASS_SINGLETON = new StaticInnerClassSingleton(); } private StaticInnerClassSingleton() { } public static StaticInnerClassSingleton getInstance(){ return SingletonHolder.STATIC_INNER_CLASS_SINGLETON; } } 6. 枚举类 6.1 破坏单例模式的几种方法 clone: 为了防止客户端使用克隆方法来创建对象，单例类不能实现Cloneable接口，即不能支持clone()方法。 反射: 由于反射可以获取到类的构造函数，包括私有构造函数，因此反射可以生成新的对象。 序列化和反序列化: 在原型模式中，我们可以通过反序列化实现深克隆，反序列化也会生成新的对象。具体来说就是每调用一次readObject()方法，都将会返回一个新建的实例对象，这个新建的实例对象不同于类在初始化时创建的实例对象。 枚举类实现单例模式是 effective java 作者极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。 6.2 枚举实现的单例 /** * 单例模式 -- 枚举类 * * @author Young * @Date 2021-05-25 20:53 */ public enum SingletonEnum { SINGLETON_ENUM(\"SINGLETON_ENUM\", \"枚举单例测试\") ; SingletonEnum(String code, String desc) { this.code = code; this.desc = desc; } private String code; private String desc; /** * 实例执行方法 */ public void doSomething() { System.out.println(String.format(\"我是枚举单例...., code: %s, desc: %s\", code, desc)); } } /** * 单例模式 -- 枚举类 测试 * * @author Young * @Date 2021-05-25 20:56 */ public class SingletonEnumTest { public static void main(String[] args) { SingletonEnum.SINGLETON_ENUM.doSomething(); } } // 结果为： 我是枚举单例...., code: SINGLETON_ENUM, desc: 枚举单例测试 反编译上述枚举单例 D:\\IdeaProjects\\java-notes\\src\\main\\java\\com\\young\\design\\pattern\\creational\\singleton>javac -encoding UTF-8 SingletonEnum.java D:\\IdeaProjects\\java-notes\\src\\main\\java\\com\\young\\design\\pattern\\creational\\singleton>javap -encoding UTF8 SingletonEnum.class Compiled from \"SingletonEnum.java\" public final class com.young.design.pattern.creational.singleton.SingletonEnum extends java.lang.Enum { public static final com.young.design.pattern.creational.singleton.SingletonEnum SINGLETON_ENUM; public static com.young.design.pattern.creational.singleton.SingletonEnum[] values(); public static com.young.design.pattern.creational.singleton.SingletonEnum valueOf(java.lang.String); public void doSomething(); static {}; } 线程安全问题 由反编译后的代码可知，SINGLETON_ENUM是static，在Java虚拟机编译的时候，static变量赋值和static代码块是在()中执行，也即类加载后执行的，优先于非静态变量和非静态代码块以及构造函数。所以，枚举实现是在实例化时就已经保证是线程安全的了。 序列化问题 Java规范中规定，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，因此在枚举类型的序列化和反序列化上，Java做了特殊的规定。在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过 java.lang.Enum 的 valueOf() 方法来根据名字查找枚举对象。也就是说，以上述枚举为例，序列化的时候只将SINGLETON_ENUM这个名称输出，反序列化的时候再通过这个名称，查找对应的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。 7. 破坏单例模式的方法及解决办法 除枚举方式外, 其他方法都会通过反射的方式破坏单例, 反射是通过调用构造方法生成新的对象，所以如果我们想要阻止单例破坏，可以在构造方法中进行判断，若已有实例, 则阻止生成新的实例，解决办法如下: private SingletonObject1(){ if (instance !=null){ throw new RuntimeException(\"实例已经存在，请通过 getInstance()方法获取\"); } } 如果单例类实现了序列化接口Serializable, 就可以通过反序列化破坏单例，所以我们可以不实现序列化接口,如果非得实现序列化接口，可以重写反序列化方法readResolve(), 反序列化时直接返回相关单例对象。 public Object readResolve() throws ObjectStreamException { return instance; } 8. 参考资料 为什么用枚举类来实现单例模式越来越流行？ 单例模式之枚举实现 枚举实现单例模式的原理 深入理解jvm--Java中init和clinit区别完全解析 powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/03建造者模式.html":{"url":"设计模式/03建造者模式.html","title":"03建造者模式","keywords":"","body":" 建造者模式 建造者模式 假设我们需要创建一个对象，该对象是由多个组件（Component）组合而成，每个组件的建立都比较复杂，但运用组件来建立所需的对象非常简单，所以我们就可以将构建复杂组件的步骤与运用组件构建对象分离，使用builder模式可以建立。 建造型模式用于创建过程稳定，但配置多变的对象，使用多个简单的对象一步一步构建成一个复杂的对象。 现在建造者模式主要用来通过链式调用生成不同的配置，比如我们要制作一杯珍珠奶茶。它的制作过程是稳定的，除了必须要知道奶茶的种类和规格外，是否加珍珠和是否加冰是可选的。使用建造者模式表示如下： public class MilkTea { private String type; private String size; private boolean pearl; private boolean ice; public MilkTea(Builder builder) { this.type = builder.getType(); this.size = builder.getSize(); this.pearl = builder.getPearl(); this.ice = builder.getIce(); } public String getType() { return type; } public void setType(String type) { this.type = type; } public String getSize() { return size; } public void setSize(String size) { this.size = size; } public boolean isPearl() { return pearl; } public void setPearl(boolean pearl) { this.pearl = pearl; } public boolean isIce() { return ice; } public void setIce(boolean ice) { this.ice = ice; } @Override public String toString() { return \"MilkTea{\" + \"type='\" + type + '\\'' + \", size='\" + size + '\\'' + \", pearl=\" + pearl + \", ice=\" + ice + '}'; } public static class Builder{ private String type = \"原味\"; private String size = \"中杯\"; private boolean pearl = false; private boolean ice = false; public Builder setType(String type) { this.type = type; return this; } public Builder setSize(String size) { this.size = size; return this; } public Builder setPearl(boolean pearl) { this.pearl = pearl; return this; } public Builder setIce(boolean ice) { this.ice = ice; return this; } public String getType() { return type; } public String getSize() { return size; } public boolean getPearl() { return pearl; } public boolean getIce() { return ice; } public MilkTea build(){ return new MilkTea(this); } } public static void main(String[] args) { MilkTea milkTea = new Builder().setType(\"111\").setSize(\"大杯\").build(); System.out.println(milkTea.toString()); } } powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/04原型模式.html":{"url":"设计模式/04原型模式.html","title":"04原型模式","keywords":"","body":" 原型模式 浅拷贝 深拷贝 原型模式 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象， 说白了就是对象复制。 浅拷贝 对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝 需要实现Cloneable 接口 Object 的 clone() 方法 深拷贝 对基本数据类型进行值传递，对引用数据类型创建一个新的对象，并复制内容 public class ProtoType { public static void main(String[] args) throws CloneNotSupportedException { Person person1 = new Person(new Man(\"John\"), 10); Person person2 = person1.clone(); System.out.println(\"parent1 = \" + person1.toString()); System.out.println(\"parent2 = \" + person2.toString()); person2.setAge(100); person2.setManName(\"abc\"); System.out.println(\"parent1 = \" + person1.toString()); System.out.println(\"parent2 = \" + person2.toString()); } public static class Person implements Cloneable{ Man man; int age = 0; public Person(Man man, int age) { this.man = man; this.age = age; } public void setManName(String manName) { this.man.setName(manName); } public void setAge(int age) { this.age = age; } @Override protected Person clone() throws CloneNotSupportedException { return (Person) super.clone(); } @Override public String toString() { return \"Parent{\" + \"name='\" + man.getName() + '\\'' + \", age=\" + age + '}'; } } public static class Man{ private String name; public Man(String name) { this.name = name; } public void setName(String name) { this.name = name; } public String getName() { return name; } } } 输入结果： parent1 = Parent{name='John', age=10} parent2 = Parent{name='John', age=10} parent1 = Parent{name='abc', age=10} parent2 = Parent{name='abc', age=100} powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/05适配器模式.html":{"url":"设计模式/05适配器模式.html","title":"05适配器模式","keywords":"","body":" 适配器模式 1. 类适配器 2. 对象适配器 3. 接口适配器 适配器模式 适配器模式(Adapter Pattern)通过定义一个适配器类作为两个不兼容的接口之间的桥梁，将一个类的接口转化为用户期望的另一个接口，使得两个或多个原本不兼容的接口可以基于适配器类一起工作。 适配器的实现主要分为三种： 类适配器：适配器与适配者之间是继承（或实现）关系 对象适配器：适配器与适配者之间是关联关系 接口适配器：适配器与适配者之间是继承（或实现）关系 1. 类适配器 在需要不改变(或者由于项目原因无法改变)原有接口或者类结构的情况下扩展类的功能以适配不同的接口，可以使用类的适配器模式。类适配器模式通过创建一个继承原有类(需要扩展的类)并实现新接口的适配器类来实现。 主要优点如下： 客户端通过适配器可以透明地调用目标接口。 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。 其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。 考虑下面的场景：我们有一个类(Adaptee),该类有一个adapteeRequest()方法。我们系统调用时，希望调用的是request()方法，这样我们的系统调用和现有的类出现不适配的情况，可以考虑使用适配器模式，新建一个Target接口，该接口有request()接口方法，然后定义适配器类ClassAdapter，该适配器类实现Target接口并继承Adaptee类，在ClassAdapter类的request()方法的实现中调用Adaptee的adapteeRequest()方法即可实现适配，详细的代码如下： /** * 被适配者 * * @author Young * @Date 2021-05-31 21:26 */ public class Adaptee { public void adapteeRequest() { System.out.println(\"被适配者的方法\"); } } /** * 目标接口 * * @author Young * @Date 2021-05-31 21:26 */ public interface Target { /** * 请求接口 */ void request(); } /** * 类适配器 * 怎么才可以在目标接口中的 request() 调用 Adaptee 的 adapteeRequest() 方法呢？ * 如果直接实现 Target 是不行的 * 如果通过一个适配器类，实现 Target 接口，同时继承了 Adaptee 类，然后在实现的 request() 方法中调用父类的 adapteeRequest() 即可实现 */ public class ClassAdapter extends Adaptee implements Target { @Override public void request() { super.adapteeRequest(); } } /** * 测试类 * * @author Young * @Date 2021-05-31 21:28 */ public class AdapterTest { public static void main(String[] args) { Target adapterTarget = new ClassAdapter(); adapterTarget.request(); } } //输出 concreteTarget目标方法 被适配者的方法 2. 对象适配器 对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成，这里稍微修改一下 Adapter 类即可将转变为对象适配器 /** * 对象适配器 * * @author Young * @Date 2021-05-31 21:30 */ public class ObjectAdapter implements Target{ /** * 适配者是对象适配器的一个属性 */ private static final Adaptee ADAPTEE = new Adaptee(); @Override public void request() { ADAPTEE.adapteeRequest(); } } 3. 接口适配器 接口适配器的场景是：当某一个接口的方法比较多，而其实现类又不想实现所有的方法，此时可以创建一个抽象的适配器类，该抽象适配器类实现部分接口方法，实现类继承此抽象适配器类从而达到目的 /** * 接口适配器的目标接口 * * @author Young * @Date 2021-05-31 21:38 */ public interface InterfaceAdapterTarget { /** * 请求接口 */ void request(); /** * 不希望实现的类 */ void uselessMethod(); } /** * 抽象适配器类 * * @author Young * @Date 2021-05-31 21:39 */ public abstract class AbstractInterfaceAdapter implements InterfaceAdapterTarget { @Override public void uselessMethod() { System.out.println(\"uselessMethod\"); } } /** * 抽象适配器的适配器类 * * @author Young * @Date 2021-05-31 21:40 */ public class InterfaceAdapter extends AbstractInterfaceAdapter{ @Override public void request() { System.out.println(\"InterfaceAdapter\"); } } /** * 测试类 * * @author Young * @Date 2021-05-31 21:28 */ public class AdapterTest { public static void main(String[] args) { InterfaceAdapterTarget interfaceAdapterTarget = new InterfaceAdapter(); interfaceAdapterTarget.request(); } } powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/06桥接模式.html":{"url":"设计模式/06桥接模式.html","title":"06桥接模式","keywords":"","body":" 桥接模式 桥接模式 桥接模式(Bridge Pattern)通过将抽象及其实现解耦，使二者可以根据需求独立变化。桥接模式用于解决在需求多变的情况下使用继承造成类爆炸的问题，扩展起来不够灵活。可以通过桥接模式将抽象部分和实现部分相分离，使其能够独立变化而相互之间的功能不受影响。具体的做法是通过定义一个桥接接口，使得实体类的功能独立于接口实现类，降低他们之间的耦合度。 桥接（Bridge）模式的优点是： 由于抽象与实现分离，所以扩展能力强； 其实现细节对客户透明。 缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。 符合合成/聚合原则 继承虽然是面向对象的三大特性之一，但继承会导致子类与父类有非常紧密的依赖关系，它会限制子类的灵活性和子类的复用性。而使用合成/聚合，也就是使用接口实现的方式，就不存在依赖问题，一个类可以实现多个接口，可以很方便地拓展功能。 桥接模式的典型例子是是JDBC和DriverManager，JDBC在连接数据库时，在各个数据库之间进行切换而不需要修改代码，因为JDBC提供了统一的接口，每个数据库都提供了各自的实现，通过一个叫做数据库驱动的程序来实现桥接即可。其实现如下： /** * 数据库驱动接口 * * @author Young * @Date 2021-06-01 21:16 */ public interface DbDriver { /** * 执行SQL * @param sqlStr */ void execute(String sqlStr); } /** * MySQL驱动 * * @author Young * @Date 2021-06-01 21:17 */ public class MySqlDbDriver implements DbDriver { @Override public void execute(String sqlStr) { System.out.println(String.format(\"I am MySQL: %s\", sqlStr)); } } /** * Oracle * * @author Young * @Date 2021-06-01 21:19 */ public class OracleDbDriver implements DbDriver{ @Override public void execute(String sqlStr) { System.out.println(String.format(\"I am Oracle: %s\", sqlStr)); } } /** * 数据库驱动桥接的桥 * * @author Young * @Date 2021-06-01 21:20 */ public class DbDriverBridge { private DbDriver dbDriver; public void setDbDriver(DbDriver dbDriver) { this.dbDriver = dbDriver; } /** * 执行SQL * * @param sqlStr */ public void execute(String sqlStr) { dbDriver.execute(sqlStr); } } /** * 桥接模式测试类 * * @author Young * @Date 2021-06-01 21:21 */ public class DbDriverBridgeTest { public static void main(String[] args) { DbDriver oracleDriver = new OracleDbDriver(); DbDriver mySqlDriver = new MySqlDbDriver(); DbDriverBridge dbDriverBridge = new DbDriverBridge(); dbDriverBridge.setDbDriver(mySqlDriver); dbDriverBridge.execute(\"MySQL\"); dbDriverBridge.setDbDriver(oracleDriver); dbDriverBridge.execute(\"Oracle\"); } } 输出： I am MySQL: MySQL I am Oracle: Oracle powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/07过滤器模式.html":{"url":"设计模式/07过滤器模式.html","title":"07过滤器模式","keywords":"","body":" 过滤器模式 过滤器模式 过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。 其实就是定义多个过滤器来筛选出符合条件的对象，过滤器和具体的业务逻辑是解耦的 /** * 首先新建一个Person，代表班级里每个人物，同时，设置姓名和性别两个属性。 * 人物对象 * * @author Young * @Date 2021-06-02 21:20 */ public class Person { /** * 姓名 */ private String name; /** * 性别 */ private String gender; public Person(String name, String gender) { this.name = name; this.gender = gender; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", gender='\" + gender + '\\'' + '}'; } } import java.util.List; /** * 过滤器接口 * * @author Young * @Date 2021-06-02 21:21 */ public interface Filter { /** * 过滤方法 * * @param persons * @return */ List filter(List persons); } /** * 女生过滤器 * * @author Young * @Date 2021-06-02 21:23 */ public class GirlFilter implements Filter { @Override public List filter(List persons) { return persons.stream().filter(person -> \"女\".equals(person.getGender()) ).collect(Collectors.toList()); } } /** * 男生过滤器 * * @author Young * @Date 2021-06-02 21:24 */ public class BoyFilter implements Filter{ @Override public List filter(List persons) { return persons.stream().filter(person -> \"男\".equals(person.getGender()) ).collect(Collectors.toList()); } } /** * 过滤器测试 * * @author Young * @Date 2021-06-02 21:25 */ public class FilterTest { public static void main(String[] args) { List persons = new ArrayList<>(15); for (int i = 0; i System.out.println(person.toString())); } } 结果: Person{name='0', gender='男'} Person{name='1', gender='男'} Person{name='2', gender='男'} Person{name='3', gender='男'} Person{name='4', gender='男'} powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/08组合模式.html":{"url":"设计模式/08组合模式.html","title":"08组合模式","keywords":"","body":" 组合模式 1. 优缺点 2. 组合模式适用场景 3. Java实例 组合模式 组合模式(Composite Pattern)又被称为部分整体模式，主要用于实现部分和整体操作的一致性。组合模式常根据树形结构来表示部分和整体之间的关系，使得用户对单个对象和组合对象的操作具有一致性。组合模式通过特定的数据结构简化了部分和整体之间的关系，使得客户端可以像处理单个元素一样来处理整体的数据集，而无需关心单个元素和整体数据集之间的内部复杂结构 1. 优缺点 优点 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码； 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”； 缺点 使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联 2. 组合模式适用场景 需要表示一个对象整体或部分层次，在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，可以一致地对待它们。 让客户能够忽略不同对象层次的变化，客户端可以针对抽象构件编程，无须关心对象层次结构的细节。 3. Java实例 /** * File抽象类 * * @author Young * @Date 2021-06-14 10:28 */ public abstract class File { String name; public File(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } /** * 显示文件属性 */ public abstract void display(); } import java.util.ArrayList; import java.util.List; /** * 该类包含对文件的增加、删除和浏览三个方法 * * @author Young * @Date 2021-06-14 10:29 */ public class Folder extends File { private List files; public Folder(String name) { super(name); files = new ArrayList(); } /** * 浏览文件夹中的文件 */ @Override public void display() { for (File file : files) { file.display(); } } /** * 向文件夹中添加文件 * * @param file * @return void */ public void add(File file) { files.add(file); } /** * 从文件夹中删除文件 * * @param file * @return void */ public void remove(File file) { files.remove(file); } } /** * 文本文件 * * @author Young * @Date 2021-06-14 10:32 */ public class TextFile extends File{ public TextFile(String name) { super(name); } @Override public void display() { System.out.println(\"这是文本文件，文件名：\" + super.getName()); } } /** * 视频文件 * * @author Young * @Date 2021-06-14 10:36 */ public class VideoFile extends File { public VideoFile(String name) { super(name); } @Override public void display() { System.out.println(\"这是影像文件，文件名：\" + super.getName()); } } /** * 图像文件 * * @author Young * @Date 2021-06-14 10:35 */ public class ImageFile extends File{ public ImageFile(String name) { super(name); } @Override public void display() { System.out.println(\"这是图像文件，文件名：\" + super.getName()); } } /** * 组合模式测试类 * * @author Young * @Date 2021-06-14 10:37 */ public class FileClientTest { public static void main(String[] args) { //总文件夹 Folder folder = new Folder(\"总文件夹\"); //向总文件夹中放入三个文件：a.txt、b.jpg、c文件夹 TextFile aText = new TextFile(\"a.txt\"); ImageFile bImage = new ImageFile(\"b.jpg\"); Folder cFolder = new Folder(\"C文件夹\"); folder.add(aText); folder.add(bImage); folder.add(cFolder); //向C文件夹中添加文件：c_1.txt、c_1.rmvb、c_1.jpg TextFile cText = new TextFile(\"c_1.txt\"); ImageFile cImage = new ImageFile(\"c_1.jpg\"); VideoFile cVideo = new VideoFile(\"c_1.rmvb\"); cFolder.add(cText); cFolder.add(cImage); cFolder.add(cVideo); //遍历总文件夹 folder.display(); //将c_1.txt删除 cFolder.remove(cText); System.out.println(\"-----------------------\"); // 再遍历总文件夹 folder.display(); } } powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/09装饰器模式.html":{"url":"设计模式/09装饰器模式.html","title":"09装饰器模式","keywords":"","body":" 装饰器模式 1. 优缺点 2. Java实例 3. JDK中装饰器模式 装饰器模式 装饰器模式(Decorator Pattern)指在无须改变原有类及类的继承关系的情况下，动态扩展一个类的功能。装饰器模式通过装饰者来包裹真实的对象，并动态地向对象添加或者撤销功能。 1. 优缺点 优点 采用装饰模式扩展对象的功能比采用继承方式更加灵活。 可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。 缺点 装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。 2. Java实例 /** * Apple * * @author Young * @Date 2021-06-14 11:18 */ public interface Apple { /** * 描述 */ void description(); } /** * 普通苹果实现 * * @author Young * @Date 2021-06-14 11:19 */ public class ConcreteApple implements Apple{ @Override public void description() { System.out.println(\"普通的苹果\"); } } /** * Apple装饰器 * * @author Young * @Date 2021-06-14 11:20 */ public class AppleDecorator implements Apple{ private Apple apple; public AppleDecorator(Apple apple) { super(); this.apple = apple; } @Override public void description() { apple.description(); } } /** * Apple装饰器 A * * @author Young * @Date 2021-06-14 11:24 */ public class AppleDecoratorA extends AppleDecorator{ public AppleDecoratorA(Apple apple) { super(apple); } @Override public void description() { System.out.println(\"红色苹果A\"); super.description(); } } /** * Apple装饰器 B * * @author Young * @Date 2021-06-14 11:25 */ public class AppleDecoratorB extends AppleDecorator{ public AppleDecoratorB(Apple apple) { super(apple); } @Override public void description() { System.out.println(\"绿色苹果B\"); super.description(); } } /** * 装饰器测试类 * * @author Young * @Date 2021-06-14 11:33 */ public class DecoratorTest { public static void main(String[] args) { ConcreteApple concreteApple = new ConcreteApple(); concreteApple.description(); System.out.println(\"#####\"); AppleDecoratorA appleDecoratorA = new AppleDecoratorA(concreteApple); appleDecoratorA.description(); System.out.println(\"#####\"); AppleDecoratorB appleDecoratorB = new AppleDecoratorB(concreteApple); appleDecoratorB.description(); } } 3. JDK中装饰器模式 装饰模式在 Java 语言中的最著名的应用莫过于 Java I/O 标准库的设计了。例如，InputStream的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、FilterWriter 以及PrintWriter等，它们都是抽象装饰类。 下面代码是为FileReader 增加缓冲区而采用的装饰类 BufferedReader 的例子： import java.io.*; public class JdkStreamTest { public static void main(String[] args) throws IOException { File file = new File(\"test1.txt\"); FileReader fileReader = new FileReader(file); BufferedReader bufferedReader = new BufferedReader(fileReader); //只能读取一个character System.out.println(fileReader.read()); //只能读取一个character System.out.println(bufferedReader.read()); //可以读取一行 System.out.println(bufferedReader.readLine()); } } Java 的IO类即是使用的装饰器模式，BufferedReader在FileReader上增加了新的功能readLine() powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/10外观模式.html":{"url":"设计模式/10外观模式.html","title":"10外观模式","keywords":"","body":" 外观模式 1. 优缺点 2. Java实例 外观模式 外观模式(Facade Pattern)也叫做门面模式，通过一个门面(Facade)向客户端提供一个访问系统的统一接口，客户端无须关心和知晓系统内各子模块(系统)之间的复杂关系，其主要目的是降低访问拥有多个子系统的复杂系统的难度，简化客户端与其之间的接口。外观模式将子系统中的功能抽象为一个统一的接口，客户端通过这个接口访问系统，使得系统使用起来更加容易。 1. 优缺点 优点 外观模式是“迪米特法则”的典型应用，它有以下主要优点： 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。 *缺点 外观模式的主要缺点如下。 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 外观模式非常简单，体现的就是 Java 中封装的思想。将多个子系统封装起来，提供一个更简洁的接口供外部调用。 2. Java实例 上班需要做的事： 签到 打开浏览器 查看邮箱 打开IDEA 下班需要做的事： 关闭IDEA 关闭浏览器 签退 使用外观模式将上下班做的事封装成一个方法 /** * 打卡 * * @author Young * @Date 2021-06-14 16:27 */ public class Sign { public void signIn() { System.out.println(\"我在签到\"); } public void signOut() { System.out.println(\"我在签退\"); } } /** * 浏览器 * * @author Young * @Date 2021-06-14 16:30 */ public class Browser { public void open() { System.out.println(\"我在打开浏览器\"); } public void close() { System.out.println(\"我在关闭浏览器\"); } } /** * Idea * * @author Young * @Date 2021-06-14 16:31 */ public class Idea { public void open(){ System.out.println(\"我在打开Idea去搬转了\"); } public void close(){ System.out.println(\"我在关闭Idea\"); } } /** * 外观模式封装上班 * * @author Young * @Date 2021-06-14 16:32 */ public class Facade { Sign sign = new Sign(); Browser browser = new Browser(); Idea idea = new Idea(); public void work() { sign.signIn(); browser.open(); idea.open(); } public void goHome() { sign.signOut(); browser.close(); idea.close(); } } /** * 外观模式测试类 * * @author Young * @Date 2021-06-14 16:33 */ public class FacadeTest { public static void main(String[] args) { //上班的行为 Sign sign = new Sign(); sign.signIn(); Browser browser = new Browser(); browser.open(); Idea idea = new Idea(); idea.open(); //使用外观模式 Facade facade = new Facade(); facade.work(); } } 由于我们每天都要做这几件事，所以我们可以使用外观模式，将这几个子系统封装起来，提供更简洁的接口 外观模式使得两种不同的类不用直接交互，而是通过一个中间件——也就是外观类——间接交互。外观类中只需要暴露简洁的接口，隐藏内部的细节，所以说白了就是封装的思想。 powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/11享元模式.html":{"url":"设计模式/11享元模式.html","title":"11享元模式","keywords":"","body":" 享元模式 1. Java实例 享元模式 享元模式(Flyweight Pattern)主要通过对象的复用来减少对象创建的次数和数量，以减少系统内存的使用和降低系统的负载。在系统需要一个对象时享元模式首先在系统中查找并尝试重用现有的对象，如果未找到匹配的对象，则创建新队形并将其缓存在系统中以便下次使用。 运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。 享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。 1. Java实例 /** * 图形接口 * * @author Young * @Date 2021-06-14 17:47 */ public interface Shape { /** * 图像方法 */ void draw(); } /** * 图形圆 * * @author Young * @Date 2021-06-14 17:50 */ public class Circle implements Shape{ private String color; private int x; private int y; private int radius; public Circle(String color){ this.color = color; } public void setX(int x) { this.x = x; } public void setY(int y) { this.y = y; } public void setRadius(int radius) { this.radius = radius; } @Override public void draw() { System.out.println(\"Circle: Draw() [Color : \" + color +\", x : \" + x +\", y :\" + y +\", radius :\" + radius); } } import java.util.HashMap; /** * 图形工厂 * * @author Young * @Date 2021-06-14 17:52 */ public class ShapeFactory { private static final HashMap CIRCLE_MAP = new HashMap<>(); public static Shape getCircle(String color) { Circle circle = (Circle) CIRCLE_MAP.get(color); if(circle == null) { circle = new Circle(color); CIRCLE_MAP.put(color, circle); System.out.println(\"Creating circle of color : \" + color); } return circle; } } powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/12代理模式.html":{"url":"设计模式/12代理模式.html","title":"12代理模式","keywords":"","body":"代理模式 代理模式(Proxy Pattern)指为对象提供一种通过代理的方式来访问并控制该对象行为的方法。在客户端不适合或者不能够直接引用一个对象时，可以通过该对象的代理对象来实现对该对象的访问，该代理对象也就是 客户端和目标对象之间的中介。 1. 优缺点 优点 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用； 代理对象可以扩展目标对象的功能； 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度； 缺点 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢； 增加了系统的复杂度； 2. 静态代理 /** * Subject * * @author Young * @Date 2021-06-14 18:36 */ public interface Subject { void operate(); } /** * RealSubject * * @author Young * @Date 2021-06-14 18:37 */ public class RealSubject implements Subject{ @Override public void operate() { System.out.println(\"RealSubject\"); } } /** * 静态代理类 * * @author Young * @Date 2021-06-14 18:38 */ public class StaticProxy implements Subject { private Subject subject = null; @Override public void operate() { if (subject == null) { subject = new RealSubject(); } System.out.print(\"I'm Proxy, I'm invoking...\"); this.subject.operate(); } } /** * 静态代理测试类 * * @author Young * @Date 2021-06-14 18:48 */ public class StaticProxyTest { public static void main(String[] args) { Subject subject = new StaticProxy(); subject.operate(); } } 3. Java动态代理 动态代理是指在运行时，动态生成代理类，即，代理类的字节码将在运行时生成并载入当前的ClassLoader 与静态代理类想比，动态类有诸多好处： 首先，不需要为真实主题(RealSubject)写一个形式上完全一样的封装类，假如主题接口中的方法很多，为每一个接口写一个代理方法也是非常烦人的事，如果接口有变动，则真实主题和代理类都要修改，不利于系统维护； 其次，使用一些动态代理的生成方法甚至可以在运行时指定代理类的执行逻辑，从而大大提升系统的灵活性。 JDK动态代理例子 /** * 动态代理 * * @author Young * @Date 2021-06-14 18:54 */ public class DynamicProxy implements InvocationHandler { Object obj = null; public Object newProxyInstance(Object realObj) { this.obj = realObj; Class classType = realObj.getClass(); return Proxy.newProxyInstance(classType.getClassLoader(), classType.getInterfaces(), this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.print(\"I'm Proxy, I'm invoking...\"); method.invoke(obj, args); System.out.println(\"invoke end!\"); return null; } } /** * 动态代理测试类 * * @author Young * @Date 2021-06-14 18:56 */ public class DynamicProxyTest { public static void main(String[] args) { Subject subject = (Subject) new DynamicProxy().newProxyInstance(new RealSubject()); subject.operate(); } } //输出结果 I'm Proxy, I'm invoking...RealSubject invoke end! powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/13责任链模式.html":{"url":"设计模式/13责任链模式.html","title":"13责任链模式","keywords":"","body":" 责任链模式 1. 优缺点 2.使用场景 3. Java实例 责任链模式 责任链模式(Responsibility of Chain)也叫做职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，责任链模式让所有请求的处理者持有下一个对象的引用，从而将请求串联成一条链，在所有请求发生时，可将请求沿着这条链传递，直到遇到该对象的处理器。 责任链模式在Web请求中很常见，比如我们要为客户端提供一个rest服务，服务端要针对客户端的请求实现用户鉴权、业务调用、结果反馈流程就可以使用责任链模式实现。 责任链模式包含以下三种角色： Handler接口，用于规定在责任链上具体要执行的方法； AbstarctHandler抽象类：持有Handler实例并通过setHandler()和getHandler()将各个具体的业务Handler串联成一个责任链，客户端上的请求在责任链上执行； 业务Handler: 用户根据具体的业务需求实现的业务逻辑。 1. 优缺点 优点： 降低耦合度。它将请求的发送者和接收者解耦 简化了对象。使得对象不需要知道链的结构 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任 增加新的请求处理类很方便。 缺点： 不能保证请求一定被接收 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用 可能不容易观察运行时的特征，有碍于除错。 2.使用场景 有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求 可动态指定一组对象处理请求。 3. Java实例 假设我们有一个日志打印的责任链，有Info、Debug、Error级别的日志打印处理器，处理器只能打印级别比自己大的日志信息，我们可以这样设计 /** * 抽象Logger类 * * @author Young * @Date 2021-06-18 20:36 */ public abstract class AbstractLogger { public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; protected int level; /** * 责任链中的下一个元素 */ protected AbstractLogger nextLogger; public void setNextLogger(AbstractLogger nextLogger) { this.nextLogger = nextLogger; } public void logMessage(int level, String message) { if (this.level debugLogger -->infoLogger errorLogger.setNextLogger(debugLogger); debugLogger.setNextLogger(infoLogger); return errorLogger; } public static void main(String[] args) { AbstractLogger loggerChain = getChainOfLoggers(); loggerChain.logMessage(AbstractLogger.INFO, \"This is an information.\"); System.out.println(); loggerChain.logMessage(AbstractLogger.DEBUG, \"This is a debug level information.\"); System.out.println(); loggerChain.logMessage(AbstractLogger.ERROR, \"This is an error information.\"); } } // 测试结果 Info::Logger: This is an information. Debug::Logger: This is a debug level information. Info::Logger: This is a debug level information. Error::Logger: This is an error information. Debug::Logger: This is an error information. Info::Logger: This is an error information. powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/14命令模式.html":{"url":"设计模式/14命令模式.html","title":"14命令模式","keywords":"","body":" 命令模式 1. 优缺点 2. Java实例 命令模式 命令模式指将请求封装为命令，基于时间驱动异步地执行，以实现命令的发送者和命令的执行者之间的解耦，提高命令发送、执行的效率和灵活度 命令模式将命令调用者与执行者解耦，有效降低系统的耦合度，增加和删除命令也非常方便 认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。 命令模式包含以下主要角色： 抽象命令类(Command) : 执行命令的接口，定义执行命令的抽象方法execute() 具体命令类(Concrete Command) : 抽象命令类的实现类，持有接收者对象，并在接受到命令后调用命令执行者的方法action()实现命令的调用和执行 命令执行者(Receiver) : 命令的具体执行者，定义了命令执行的具体方法action() 命令调用者(Invoker) : 接收客户端的命令并异步执行 1. 优缺点 优点： 降低了系统耦合度，命令模式能将调用操作的对象与实现该操作的对象解耦 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。 2. Java实例 /** * Stock请求类 * * @author Young * @Date 2021-06-19 14:05 */ public class Stock { private String name = \"ABC\"; private int quantity = 10; public void buy(){ System.out.println(\"Stock [ Name: \"+name+\", Quantity: \" + quantity +\" ] bought\"); } public void sell(){ System.out.println(\"Stock [ Name: \"+name+\", Quantity: \" + quantity +\" ] sold\"); } } /** * 命令接口 * * @author Young * @Date 2021-06-19 14:06 */ public interface Order { /** * 命令执行 */ void execute(); } /** * 卖股票的命令类 * * @author Young * @Date 2021-06-19 14:09 */ public class SellStock implements Order { private Stock abcStock; public SellStock(Stock abcStock) { this.abcStock = abcStock; } @Override public void execute() { abcStock.sell(); } } /** * 买股票的命令实现 * * @author Young * @Date 2021-06-19 14:07 */ public class BuyStock implements Order { private Stock abcStock; public BuyStock(Stock abcStock) { this.abcStock = abcStock; } @Override public void execute() { abcStock.buy(); } } /** * 创建命令类 * * @author Young * @Date 2021-06-19 14:09 */ public class Broker { private List orderList = new ArrayList(); public void takeOrder(Order order) { orderList.add(order); } public void executeOrder() { for (Order order : orderList) { order.execute(); } orderList.clear(); } } /** * 命令模式测试类 * * @author Young * @Date 2021-06-19 14:11 */ public class CommandPatternDemo { public static void main(String[] args) { Stock abcStock = new Stock(); BuyStock buyStockOrder = new BuyStock(abcStock); SellStock sellStockOrder = new SellStock(abcStock); // 接受命令 Broker broker = new Broker(); broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); //执行命令 broker.executeOrder(); } } powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/15解释器模式.html":{"url":"设计模式/15解释器模式.html","title":"15解释器模式","keywords":"","body":"解释器模式 解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 主要解决：对于一些固定文法构建一个解释句子的解释器。 何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。 使用场景： 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树 一些重复出现的问题可以用一种简单的语言来进行表达 一个简单语法需要解释的场景 1. 优缺点 优点： 可扩展性比较好，灵活 增加了新的解释表达式的方式 易于实现简单文法 缺点： 可利用场景比较少 对于复杂的文法比较难维护 解释器模式会引起类膨胀 解释器模式采用递归调用方法 2. Java实例 /** * 表达式接口 * * @author Young * @Date 2021-06-20 20:20 */ public interface Expression { /** * 解释表达式 * * @param context * @return */ boolean interpret(String context); } /** * 表达式接口实现类， 如果要解释的表达式context中包含data则解释为true，否则解释为false * * @author Young * @Date 2021-06-20 20:20 */ public class TerminalExpression implements Expression { private String data; public TerminalExpression(String data) { this.data = data; } @Override public boolean interpret(String context) { if (context.contains(data)) { return true; } return false; } } //创建or和and解释器 /** * expr1包含context或者expr2包含context则解释为true,否则解释为false * * @author Young * @Date 2021-06-20 20:21 */ public class OrExpression implements Expression { private Expression expr1 = null; private Expression expr2 = null; public OrExpression(Expression expr1, Expression expr2) { this.expr1 = expr1; this.expr2 = expr2; } @Override public boolean interpret(String context) { return expr1.interpret(context) || expr2.interpret(context); } } /** * 如果expr1包含context且expr2包含context则解释为true,否则解释为false * * @author Young * @Date 2021-06-20 20:22 */ public class AndExpression implements Expression { private Expression expr1 = null; private Expression expr2 = null; public AndExpression(Expression expr1, Expression expr2) { this.expr1 = expr1; this.expr2 = expr2; } @Override public boolean interpret(String context) { return expr1.interpret(context) && expr2.interpret(context); } } /** * 解释器模式测试类 * * @author Young * @Date 2021-06-20 20:23 */ public class InterpreterPatternDemo { /** * 规则：Robert 和 John 是男性 */ public static Expression getMaleExpression() { Expression robert = new TerminalExpression(\"Robert\"); Expression john = new TerminalExpression(\"John\"); return new OrExpression(robert, john); } /** * 规则：Julie 是一个已婚的女性 */ public static Expression getMarriedWomanExpression() { Expression julie = new TerminalExpression(\"Julie\"); Expression married = new TerminalExpression(\"Married\"); return new AndExpression(julie, married); } public static void main(String[] args) { Expression maleExpression = getMaleExpression(); Expression marriedWomanExpression = getMarriedWomanExpression(); System.out.println(\"John is male? \" + maleExpression.interpret(\"John\")); System.out.println(\"Julie is a married women? \" + marriedWomanExpression.interpret(\"Married Julie\")); } } //输出 John is male? true Julie is a married women? true powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/16迭代器模式.html":{"url":"设计模式/16迭代器模式.html","title":"16迭代器模式","keywords":"","body":" 迭代器模式 1. 优缺点 2. Java实例 迭代器模式 迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 主要解决：不同的方式来遍历整个整合对象。 何时使用：遍历一个聚合对象。 1. 优缺点 其主要优点如下： 访问一个聚合对象的内容而无须暴露它的内部表示 遍历任务交由迭代器完成，这简化了聚合类 它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历 增加新的聚合类和迭代器类都很方便，无须修改原有代码 封装性良好，为遍历不同的聚合结构提供一个统一的接口 其主要缺点是 增加了类的个数，这在一定程度上增加了系统的复杂性。 2. Java实例 /** * 迭代器类 * * @author Young * @Date 2021-06-19 20:27 */ public interface Iterator { /** * 是否有下一个 * * @return */ public boolean hasNext(); /** * 下一个 * * @return */ public Object next(); } /** * 容器类接口 * * @author Young * @Date 2021-06-19 20:28 */ public interface Container { /** * 返回迭代器 * * @return */ Iterator getIterator(); } /** * 实现Container接口的名字仓库 * * @author Young * @Date 2021-06-19 20:32 */ public class NameRepository implements Container { public String[] names = {\"Robert\", \"John\", \"Julie\", \"Lora\"}; @Override public Iterator getIterator() { return new NameIterator(); } private class NameIterator implements Iterator { int index; @Override public boolean hasNext() { if (index powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/17中介模式.html":{"url":"设计模式/17中介模式.html","title":"17中介模式","keywords":"","body":" 中介者模式 1. 优缺点 2. Java实例 中介者模式 中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。 意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。 何时使用：多个类相互耦合，形成了网状结构。 应用实例： 中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易 机场调度系统 MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。 使用场景： 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 1. 优缺点 优点： 降低了类的复杂度，将一对多转化成了一对一 各个类之间的解耦 符合迪米特原则。 缺点： 中介者会庞大，变得复杂难以维护。 2. Java实例 通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 ChatRoom 和 User。User对象使用ChatRoom方法来分享他们的消息。 演示类MediatorPatternDemo，使用 User 对象来显示他们之间的通信。 /** * 聊天室 * * @author Young * @Date 2021-06-19 20:22 */ public class ChatRoom { public static void showMessage(User user, String message){ System.out.println(new Date().toString() + \" [\" + user.getName() +\"] : \" + message); } } /** * 用户类 * * @author Young * @Date 2021-06-19 20:23 */ public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public User(String name) { this.name = name; } public void sendMessage(String message) { ChatRoom.showMessage(this, message); } } /** * 中介者模式测试类 * * @author Young * @Date 2021-06-19 20:23 */ public class MediatorPatternDemo { public static void main(String[] args) { User robert = new User(\"Robert\"); User john = new User(\"John\"); robert.sendMessage(\"Hi! John!\"); john.sendMessage(\"Hello! Robert!\"); } } //输出 Thu Jan 31 16:05:46 IST 2013 [Robert] : Hi! John! Thu Jan 31 16:05:46 IST 2013 [John] : Hello! Robert! powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/18备忘录模式.html":{"url":"设计模式/18备忘录模式.html","title":"18备忘录模式","keywords":"","body":" 备忘录模式 1. 优缺点 2. Java实例 备忘录模式 每个人都有犯错误的时候，都希望有种“后悔药”能弥补自己的过失，让自己重新开始，但现实是残酷的。在计算机应用中，客户同样会常常犯错误，能否提供“后悔药”给他们呢？当然是可以的，而且是有必要的。这个功能由“备忘录模式”来实现。 其实很多应用软件都提供了这项功能，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。 备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。 意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有\"后悔药\"可吃。 使用场景： 需要保存/恢复数据的相关状态场景 提供一个可回滚的操作。 1. 优缺点 优点： 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态 实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点： 消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 2. Java实例 /** * 备忘录 * * @author Young * @Date 2021-06-20 20:14 */ public class Memento { private String state; public Memento(String state) { this.state = state; } public String getState() { return state; } } /** * 备忘录列表 * * @author Young * @Date 2021-06-20 20:15 */ public class CareTaker { private List mementoList = new ArrayList(); public void add(Memento state){ mementoList.add(state); } public Memento get(int index){ return mementoList.get(index); } } /** * 备忘录中要记录的对象 * * @author Young * @Date 2021-06-20 20:16 */ public class Originator { private String state; public void setState(String state){ this.state = state; } public String getState(){ return state; } public Memento saveStateToMemento(){ return new Memento(state); } public void getStateFromMemento(Memento Memento){ state = Memento.getState(); } } //测试类 public class MementoPatternDemo { public static void main(String[] args) { Originator originator = new Originator(); CareTaker careTaker = new CareTaker(); originator.setState(\"State #1\"); originator.setState(\"State #2\"); careTaker.add(originator.saveStateToMemento()); originator.setState(\"State #3\"); careTaker.add(originator.saveStateToMemento()); originator.setState(\"State #4\"); System.out.println(\"Current State: \" + originator.getState()); originator.getStateFromMemento(careTaker.get(0)); System.out.println(\"First saved State: \" + originator.getState()); originator.getStateFromMemento(careTaker.get(1)); System.out.println(\"Second saved State: \" + originator.getState()); } } //输出 Current State: State #4 First saved State: State #2 Second saved State: State #3 powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/19观察者模式.html":{"url":"设计模式/19观察者模式.html","title":"19观察者模式","keywords":"","body":" 观察者模式 1. 优缺点 2. Java实例 观察者模式 指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 1. 优缺点 优点： 观察者和被观察者是抽象耦合的 建立一套触发机制。 缺点： 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 2. Java实例 /** * 被观察者接口 * * @author Young * @Date 2021-06-19 14:41 */ public interface Subject { /** * 注册观察者 * * @param o */ public void registerObserver(Observer o); /** * 移除观察者 * * @param o */ public void removeObserver(Observer o); /** * 通知观察者 * * @param message */ public void notifyObserver(String message); } /** * 微信服务器被观察者 * * @author Young * @Date 2021-06-19 14:42 */ public class WechatServerSubject implements Subject { private List list; public WechatServerSubject() { list = new ArrayList(); } @Override public void registerObserver(Observer o) { list.add(o); } @Override public void removeObserver(Observer o) { if (!list.isEmpty()) { list.remove(o); } } @Override public void notifyObserver(String message) { System.out.println(\"微信服务更新消息： \" + message); for (Observer o : list) { o.update(message); } } } /** * 观察者接口 * * @author Young * @Date 2021-06-19 14:40 */ public interface Observer { /** * 更新消息 * * @param message */ void update(String message); } /** * 具体的观察者 * * @author Young * @Date 2021-06-19 14:45 */ public class User implements Observer { private String name; public User(String name) { this.name = name; } @Override public void update(String message) { read(message); } public void read(String message) { System.out.println(name + \" 收到推送消息： \" + message); } } /** * 观察者模式测试 * * @author Young * @Date 2021-06-19 14:47 */ public class ObserverTest { public static void main(String[] args) { //被观察者 Subject server = new WechatServerSubject(); //定义三个观察者 Observer userZhang = new User(\"ZhangSan\"); Observer userLi = new User(\"LiSi\"); Observer userWang = new User(\"WangWu\"); //观察者注册到 被观察者 server.registerObserver(userZhang); server.registerObserver(userLi); server.registerObserver(userWang); server.notifyObserver(\"PHP是世界上最好用的语言！\"); System.out.println(\"----------------------------------------------\"); //被观察者状态改变， 依次通知观察者 server.notifyObserver(\"JAVA是世界上最好用的语言！\"); } } powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/20状态模式.html":{"url":"设计模式/20状态模式.html","title":"20状态模式","keywords":"","body":"状态模式 在软件开发过程中，应用程序中的有些对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。当有状态的对象与外部事件产生互动时，其内部状态会发生改变，从而使得其行为也随之发生改变。如人的情绪有高兴的时候和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。 对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 语句来做状态判断，再进行不同情况的处理。但当对象的状态很多时，程序会变得很复杂。而且增加新的状态要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展。 以上问题如果采用“状态模式”就能很好地得到解决。状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，放到一系列的状态类当中，这样可以把原来复杂的逻辑判断简单化。 意图：允许对象在内部状态发生改变时改变它的行为，对象 看起来好像修改了它的类。 主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 使用场景： 行为随状态改变而改变的场景 条件、分支语句的代替者。 1. 优缺点 优点： 封装了转换规则 枚举可能的状态，在枚举状态之前需要确定状态种类 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数 缺点： 状态模式的使用必然会增加系统类和对象的个数 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱 状态模式对\"开闭原则\"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 2. Java实例 /** * 状态接口 * * @author Young * @Date 2021-06-19 15:34 */ public interface State { /** * 根据状态而采取的动作 * * @param context */ void doAction(Context context); } /** * 开始状态 * * @author Young * @Date 2021-06-19 15:35 */ public class StartState implements State { @Override public void doAction(Context context) { System.out.println(\"Player is in start state\"); context.setState(this); } @Override public String toString(){ return \"Start State\"; } } /** * 结束状态 * * @author Young * @Date 2021-06-19 15:35 */ public class StopState implements State { @Override public void doAction(Context context) { System.out.println(\"Player is in stop state\"); context.setState(this); } @Override public String toString(){ return \"Stop State\"; } } /** * Context * * @author Young * @Date 2021-06-19 15:34 */ public class Context { private State state; public Context(){ state = null; } public void setState(State state){ this.state = state; } public State getState(){ return state; } } /** * 状态模式测试类 * * @author Young * @Date 2021-06-19 15:36 */ public class StatePatternDemo { public static void main(String[] args) { Context context = new Context(); StartState startState = new StartState(); startState.doAction(context); System.out.println(context.getState().toString()); StopState stopState = new StopState(); stopState.doAction(context); System.out.println(context.getState().toString()); } } powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/21策略模式.html":{"url":"设计模式/21策略模式.html","title":"21策略模式","keywords":"","body":" 策略模式 1. 优缺点 2. Java实例 策略模式 该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。 1. 优缺点 优点： 算法可以自由切换 避免使用多重条件判断 扩展性良好。 缺点： 策略类会增多 所有策略类都需要对外暴露。 2. Java实例 策略模式往往和简单工厂方法结合 /** * 策略模式接口 * * @author Young * @Date 2021-06-19 14:28 */ public interface Strategy { /** * 计算两个数字 * * @param num1 * @param num2 * @return */ int calc(int num1, int num2); } /** * 加法策略 * * @author Young * @Date 2021-06-19 14:29 */ public class AddStrategy implements Strategy{ @Override public int calc(int num1, int num2) { return num1 + num2; } } /** * 减法策略 * * @author Young * @Date 2021-06-19 14:32 */ public class SubStrategy implements Strategy { @Override public int calc(int num1, int num2) { return num1 - num2; } } /** * 策略工厂 * * @author Young * @Date 2021-06-19 14:33 */ public class StrategyFactory { private static Map STRATEGY_MAP; static { STRATEGY_MAP = new HashMap<>(4); STRATEGY_MAP.put(\"+\", new AddStrategy()); STRATEGY_MAP.put(\"-\", new SubStrategy()); } public Strategy getStrategy(String key) { return STRATEGY_MAP.get(key); } } /** * 策略模式测试类 * * @author Young * @Date 2021-06-19 14:35 */ public class StrategyTest { public static void main(String[] args) { StrategyFactory strategyFactory = new StrategyFactory(); Strategy strategy = strategyFactory.getStrategy(\"+\"); System.out.println(\"1 + 3 = \" + strategy.calc(1, 3)); } } powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/22模板方法.html":{"url":"设计模式/22模板方法.html","title":"22模板方法","keywords":"","body":" 模板方法 1. 优缺点 2. Java实例 模板方法 定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。 通俗点的理解就是 ：完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。 1. 优缺点 该模式的主要优点如下： 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。 它在父类中提取了公共的部分代码，便于代码复用。 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。 该模式的主要缺点如下 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。 2. Java实例 /** * 游戏模板类 * * @author Young * @Date 2021-06-19 14:19 */ public abstract class AbstractGame { /** * 玩游戏的模板方法 */ public final void play(){ //初始化游戏 initialize(); //开始游戏 startPlay(); //结束游戏 endPlay(); } /** * 初始化游戏 */ abstract void initialize(); /** * 开始游戏 */ abstract void startPlay(); /** * 结束游戏 */ abstract void endPlay(); } /** * 实现类1 * * @author Young * @Date 2021-06-19 14:21 */ public class Cricket extends AbstractGame { @Override void endPlay() { System.out.println(\"Cricket Game Finished!\"); } @Override void initialize() { System.out.println(\"Cricket Game Initialized! Start playing.\"); } @Override void startPlay() { System.out.println(\"Cricket Game Started. Enjoy the game!\"); } } /** * 实现类2 * * @author Young * @Date 2021-06-19 14:21 */ public class Football extends AbstractGame{ @Override void endPlay() { System.out.println(\"Football Game Finished!\"); } @Override void initialize() { System.out.println(\"Football Game Initialized! Start playing.\"); } @Override void startPlay() { System.out.println(\"Football Game Started. Enjoy the game!\"); } } /** * 模板方法测试类 * * @author Young * @Date 2021-06-19 14:23 */ public class TemplatePatternDemo { public static void main(String[] args) { AbstractGame game = new Cricket(); game.play(); System.out.println(); game = new Football(); game.play(); } } powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"设计模式/23访问者模式.html":{"url":"设计模式/23访问者模式.html","title":"23访问者模式","keywords":"","body":" 访问者模式 1. 优缺点 2. Java实例 访问者模式 在现实生活中，有些集合对象中存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。例如，公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药。 这样的例子还有很多，例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在“购物车”中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。 这些被处理的数据元素相对稳定而访问方式多种多样的数据结构，如果用“访问者模式”来处理比较方便。访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。 访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。 意图：主要将数据结构与数据操作分离。 主要解决：稳定的数据结构和易变的操作耦合问题。 何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作\"污染\"这些对象的类，使用访问者模式将这些封装到类中。 1. 优缺点 优点： 符合单一职责原则 优秀的扩展性 灵活性 缺点： 具体元素对访问者公布细节，违反了迪米特原则 具体元素变更比较困难 违反了依赖倒置原则，依赖了具体类，没有依赖抽象 2. Java实例 年底，CEO和CTO开始评定员工一年的工作绩效，员工分为工程师和经理，CTO关注工程师的代码量、经理的新产品数量；CEO关注的是工程师的KPI和经理的KPI以及新产品数量。 由于CEO和CTO对于不同员工的关注点是不一样的，这就需要对不同员工类型进行不同的处理。访问者模式此时可以派上用场了。 /** * 员工基类 Staff 类定义了员工基本信息及一个 accept 方法，accept 方法表示接受访问者的访问，由子类具体实现。Visitor 是个接口，传入不同的实现类，可访问不同的数据。 * * @author Young * @Date 2021-06-20 19:57 */ public abstract class Staff { public String name; /** * 员工KPI */ public int kpi; public Staff(String name) { this.name = name; kpi = new Random().nextInt(10); } /** * 核心方法，接受Visitor的访问 * * @param visitor */ public abstract void accept(Visitor visitor); } /** * 工程师 * * @author Young * @Date 2021-06-20 19:59 */ public class Engineer extends Staff { public Engineer(String name) { super(name); } @Override public void accept(Visitor visitor) { visitor.visit(this); } /** * 工程师一年的代码数量 * * @return */ public int getCodeLines() { return new Random().nextInt(10 * 10000); } } /** * 经理 * * @author Young * @Date 2021-06-20 20:00 */ public class Manager extends Staff { public Manager(String name) { super(name); } @Override public void accept(Visitor visitor) { visitor.visit(this); } /** * 一年做的产品数量 */ public int getProducts() { return new Random().nextInt(10); } } //工程师是代码数量，经理是产品数量，他们的职责不一样，也就是因为差异性，才使得访问模式能够发挥它的作用。Staff、Engineer、Manager 3个类型就是对象结构，这些类型相对稳定，不会发生变化。 //然后将这些员工添加到一个业务报表类中，公司高层可以通过该报表类的 showReport 方法查看所有员工的业绩，具体代码如下： import java.util.LinkedList; import java.util.List; /** * 员工业务报表类 * * @author Young * @Date 2021-06-20 20:02 */ public class BusinessReport { private List mStaffs = new LinkedList<>(); public BusinessReport() { mStaffs.add(new Manager(\"经理-A\")); mStaffs.add(new Engineer(\"工程师-A\")); mStaffs.add(new Engineer(\"工程师-B\")); mStaffs.add(new Engineer(\"工程师-C\")); mStaffs.add(new Manager(\"经理-B\")); mStaffs.add(new Engineer(\"工程师-D\")); } /** * 为访问者展示报表 * * @param visitor 公司高层，如CEO、CTO */ public void showReport(Visitor visitor) { for (Staff staff : mStaffs) { staff.accept(visitor); } } } /** * 定义了一个 Visitor 接口，该接口有两个 visit 函数，参数分别是 Engineer、Manager，也就是说对于 Engineer、Manager 的访问会调用两个不同的方法，以此达成区别对待、差异化处理。 * * @author Young * @Date 2021-06-20 20:04 */ public interface Visitor { /** * 访问工程师类型 * * @param engineer */ void visit(Engineer engineer); /** * 访问经理类型 * * @param manager */ void visit(Manager manager); } /** * CEO访问者 * * @author Young * @Date 2021-06-20 20:05 */ public class CEOVisitor implements Visitor { @Override public void visit(Engineer engineer) { System.out.println(\"工程师: \" + engineer.name + \", KPI: \" + engineer.kpi); } @Override public void visit(Manager manager) { System.out.println(\"经理: \" + manager.name + \", KPI: \" + manager.kpi + \", 新产品数量: \" + manager.getProducts()); } } /** * CTO访问者 * * @author Young * @Date 2021-06-20 20:06 */ public class CTOVisitor implements Visitor { @Override public void visit(Engineer engineer) { System.out.println(\"工程师: \" + engineer.name + \", 代码行数: \" + engineer.getCodeLines()); } @Override public void visit(Manager manager) { System.out.println(\"经理: \" + manager.name + \", 产品数量: \" + manager.getProducts()); } } //在CEO的访问者中，CEO关注工程师的 KPI，经理的 KPI 和新产品数量，通过两个 visitor 方法分别进行处理。如果不使用 Visitor 模式，只通过一个 visit 方法进行处理，那么就需要在这个 visit 方法中进行判断，然后分别处理，代码大致如下： public class ReportUtil { public void visit(Staff staff) { if (staff instanceof Manager) { Manager manager = (Manager) staff; System.out.println(\"经理: \" + manager.name + \", KPI: \" + manager.kpi + \", 新产品数量: \" + manager.getProducts()); } else if (staff instanceof Engineer) { Engineer engineer = (Engineer) staff; System.out.println(\"工程师: \" + engineer.name + \", KPI: \" + engineer.kpi); } } } //这就导致了 if-else 逻辑的嵌套以及类型的强制转换，难以扩展和维护，当类型较多时，这个 ReportUtil 就会很复杂。使用 Visitor 模式，通过同一个函数对不同对元素类型进行相应对处理，使结构更加清晰、灵活性更高。 /** * 访问者模式测试 * * @author Young * @Date 2021-06-20 20:07 */ public class VisitorClientTest { public static void main(String[] args) { // 构建报表 BusinessReport report = new BusinessReport(); System.out.println(\"=========== CEO看报表 ===========\"); report.showReport(new CEOVisitor()); System.out.println(\"=========== CTO看报表 ===========\"); report.showReport(new CTOVisitor()); } } //输出 =========== CEO看报表 =========== 经理: 经理-A, KPI: 9, 新产品数量: 0 工程师: 工程师-A, KPI: 6 工程师: 工程师-B, KPI: 6 工程师: 工程师-C, KPI: 8 经理: 经理-B, KPI: 2, 新产品数量: 6 工程师: 工程师-D, KPI: 6 =========== CTO看报表 =========== 经理: 经理-A, 产品数量: 3 工程师: 工程师-A, 代码行数: 62558 工程师: 工程师-B, 代码行数: 92965 工程师: 工程师-C, 代码行数: 58839 经理: 经理-B, 产品数量: 6 工程师: 工程师-D, 代码行数: 53125 注：访问者模式参考https://www.jianshu.com/p/1f1049d0a0f4 powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"spring/readme.html":{"url":"spring/readme.html","title":"spring","keywords":"","body":"Spring框架相关的 powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"spring/spring-bean生命周期.html":{"url":"spring/spring-bean生命周期.html","title":"spring-bean生命周期","keywords":"","body":" Spring Bean 生命周期 生命周期 关键接口说明 相关Aware接口 BeanPostProcessor 初始化方法 @PostConstruct XML中定义的init-method 销毁bean Spring Bean 生命周期 生命周期 关键接口说明 相关Aware接口 Aware接口很好理解，其实就是向spring bean中注入相关的对象实例 BeanPostProcessor MergedBeanDefinitionPostProcessor和InstantiationAwareBeanPostProcessor都继承BeanPostProcessor接口 下面对这些接口的功能进行简单描述 InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation(Class beanClass, String beanName) 可以使用返回值替换bean, 即返回的bean就是IOC容器中缓存的bean，返回值不为null, 不会执行上图中该方法之后的方法了 MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class beanType, String beanName) 把RootBeanDefinition传过来，可以修改该RootBeanDefinition InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation(Object bean, String beanName) bean实例化之后, 返回true即需要设置properties，否则不会设置properties, 包括自动注入的属性 InstantiationAwareBeanPostProcessor#postProcessProperties(PropertyValues pvs, Object bean, String beanName) 可以修改属性值，如果不需要修改就返回null, 否则实际返回的就是修改后的属性值 InstantiationAwareBeanPostProcessor#postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) spring5.1之后即废弃该方法, 而在postProcessProperties中返回属性值 BeanPostProcessor#postProcessBeforeInitialization(Object bean, String beanName) bean实例化和初始化之后，初始化方法执行之前，可以修改bean，比如返回一个包装类，如果不需要修改bean则返回原bean实例 InitializingBean#afterPropertiesSet() @PostConstruct方法执行之后 BeanPostProcessor#postProcessAfterInitialization(Object bean, String beanName) bean的初始化方法执行之后，可以修改bean，比如返回一个包装类，如果不需要修改bean则返回原bean实例 初始化方法 @PostConstruct @PostConstruct注解的初始化方法，执行时bean的属性都已经注入了, 但是仍然存在bean的某个属性只是实例化了，但是并没有初始化的可能性 XML中定义的init-method 和@PostConstruct注解的初始化方法类似，执行时间在@PostConstruct注解的方法之后，执行时bean的属性都已经注入了, 但是仍然存在bean的某个属性只是实例化了，但是并没有初始化的可能性 销毁bean 销毁bean时，spring也提供了回调接口，主要包括如下三个： @PreDestroy DisposableBean#destroy() XML中定义的destroy-method powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"唯一ID/unique_id.html":{"url":"唯一ID/unique_id.html","title":"分布式唯一ID","keywords":"","body":" 分布式唯一ID 1. 背景 2. 概念 2.1 什么是分布式唯一ID 2.2 分布式唯一ID的特性 2.3 单调递增和趋势递增 2.4 设计分布式ID系统需注意的点 2.5 分布式ID系统的难点 3. 分布式ID生成方案 3.1 UUID 3.1.1 UUID概念 3.1.2 UUID优缺点 3.1.3 Java生成UUID 3.2 数据库自增 3.2.1 概念 3.2.2 优缺点 3.2.3 MySQL设置自增的方式 3.3 数据库集群模式 3.3.1 原理 3.3.2 优缺点 3.3.3 MySQL设置起始值和步长的方法 3.4 数据库号段模式 3.4.1 原理 3.4.2 优缺点 3.4.3 实现 3.4.3.1 乐观锁实现 3.4.3.2 悲观锁实现 3.5 Redis/Zookeeper 3.5.1 Redis方式原理 3.5.1.1 强依赖redis方案 3.5.1.2 弱依赖redis方案 3.5.2 优缺点 3.5.3 实现(redis自增模式的实现) 3.6 雪花算法 3.6.1 原理 3.6.2 优缺点 3.6.3 实现 3.7 美团Leaf算法 3.8 百度uid-generator 3.9 TinyId 4 分布式ID生成方案总结 5 参考资料 分布式唯一ID 1. 背景 我们在设计和实现互联网系统时，往往需要使用到唯一ID。唯一ID标识唯一的一条业务请求，如在电商系统中，ID表示系统中唯一的一个订单，支付系统中表示唯一的一条交易请求。在单机应用中，唯一ID的生成是比较简单的，我们只需保证ID在单机上面是唯一的即可；但目前互联网应用多为微服务应用，同时随着业务的逐渐增长，必须对业务进行分库分表，而且业务应用往往是多实例部署的，这就要求ID在多个微服务应用和多个应用实例之间是唯一。目前业界有很多成熟的唯一ID生成方案，下面我们来看下这些分布式唯一的ID生成方案。 2. 概念 2.1 什么是分布式唯一ID 分布式唯一ID, 应该拆开来解释: 唯一ID: 顾名思义, 这个就不用多解释了 分布式: 分布式对应的是单机应用, 单机应用中唯一ID即是唯一ID，而分库分表应用中多实例之间, 各微服务应用之间全局唯一的ID即是分布式式唯一ID 2.2 分布式唯一ID的特性 全局唯一：唯一ID，顾名思义； 高性能：ID生成的性能要高，否则会影响业务系统的性能； 高可用：ID生成服务要是高可用的，否则一旦出现不可用则会影响业务系统的可用性； 递增；尽量保证是递增的，因为业务系统可能需要根据ID进行排序，分为单调递增和趋势递增； 长度：长度尽可能的短； 侵入性小：尽量做到对业务系统无侵入。 此外，根据业务的不同，还可能要存在其他特性： 时间：有的ID中需要包含时间戳； 业务含义：这个要看具体的业务需求。 2.3 单调递增和趋势递增 单调递增：ID是严格递增的，后面的请求ID一定比之前的请求的ID大； 趋势递增：ID的整体趋势是递增的，不过存在后面的请求的ID比之前的请求ID小的情况。比如这样的ID生成方案：考虑这样的一个场景，2个实例的业务应用，实例1缓存0-1000的ID在进程中，实例2缓存1001-2000的ID在进程中，请求1先请求实例2（随机负载均衡），ID为1001，然后1分钟后请求2请求实例1，ID为0，即出现后面的请求的ID比之前的请求的ID小的情况，但是ID分配的整体趋势是递增的。 2.4 设计分布式ID系统需注意的点 时钟回退：如果ID中包含时间戳信息，需考虑时钟回退的场景，如果出现时钟回退则可能出现重复ID； 多线程问题：ID生成往往是在多线程的环境下的，因此需要注意多线程问题； 数据库性能：有些ID生成算法依赖数据库中的记录，需要考虑数据库的性能问题以及多线程引发的数据库锁问题 2.5 分布式ID系统的难点 ID长度尽可能的短：我们的ID大多数是需要在数据库中存储的，越长的ID占用的空间越多；如果使用该ID作为MySQL的主键，主键也是要求尽可能的短的，所以ID长度要尽可能的短。随之而来的问题是，越短的ID，其中包含的信息越少（信息熵越小），冲突的可能性就越大； 多线程问题：多实例之间，同一实例之间的线程都会抢ID，因此必须注意多线程问题，解决方法大部分是加锁，如果线程之间竞争严重，则严重形象性能。 3. 分布式ID生成方案 3.1 UUID 3.1.1 UUID概念 UUID(universally unique identifier)是一串随机的32位长度的数据，每一位是16进制表示，所以总计能够表示2^128的数字 据统计若每纳秒产生1百万个 UUID，要花100亿年才会将所有 UUID 用完 UUID的生成用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字 UUID为16进制的32字节长度，中间以-相连，形式为8-4-4-4-12，所以说长度也可以是36，不过使用时一般不包含-，UUID的形式如下： ef56e7fd-225b-44b8-b96d-4591bde0945b ********-****-M***-N***-************ 上面的以数字M开头的四位表示UUID 版本，目前UUID的规范有5个版本，M可选值为1, 2, 3, 4, 5 ;各个版本的具体介绍如下所示： version 1：0001。基于时间和 MAC 地址。由于使用了 MAC 地址，因此能够确保唯一性，但是同时也暴露了 MAC 地址，私密性不够好。 version 2：0010。DCE 安全的 UUID。该版本在规范中并没有仔细说明，因此并没有具体的实现。 version 3：0011。基于名字空间 (MD5)。用户指定一个名字空间和一个字符串，通过 MD5 散列，生成 UUID。字符串本身需要是唯一的。 version 4：0100。基于随机数。虽然是基于随机数，但是重复的可能性可以忽略不计，因此该版本也是被经常使用的版本。 version 5：0101。基于名字空间 (SHA1)。跟 Version 3 类似，但是散列函数编程了 SHA1。 上面以数字N开头的四个位表示 UUID 变体( variant )，变体是为了能兼容过去的 UUID，以及应对未来的变化，目前已知的变体有如下几种，因为目前正在使用的 UUID 都是 variant1，所以取值只能是 8，9，a，b 中的一个(分别对应1000,1001,1010,1011)。 variant 0：0xxx。为了向后兼容预留。 variant 1：10xx。当前正在使用的。 variant 2：11xx。为早期微软 GUID 预留。 variant 3：111x。为将来扩展预留。目前暂未使用。 3.1.2 UUID优缺点 优点 无需网络，单机即可生成 速度快 生成简单，有内置的函数库可直接实现 没有业务含义，随机性较好，保密性强(业务层保密，有些版本的UUID可泄露IP或者MAC地址) 机器生成，可保证唯一，讲道理不会重复，但是也存在重复的概率(很低) 缺点 没有业务含义，如果ID中需要业务含义则不适用UUID 太长了，32位长度 无序，可读性差 有些版本的UUID可泄露IP或者MAC地址 3.1.3 Java生成UUID Java内置了java.util.UUID类，其中内置了四种版本的UUID生成策略,包括基于时间和MAC地址的、DCE 安全的UUID、基于名字空间(MD5)和基于随机数的: There are four different basic types of UUIDs: time-based, DCE security, name-based, and randomly generated UUIDs. These types have a version value of 1, 2, 3 and 4, respectively. 比较常用的即是基于随机数的UUID生成，下面是Java的使用方法 UUID.randomUUID().toString(); 3.2 数据库自增 3.2.1 概念 使用数据库的id自增策略,比如Mysql的auto_increment 3.2.2 优缺点 优点 ID单调递增，对业务友好，利于分页和排序； 简单，代码中无需设置，只需要在建表时设置主机递增即可； 缺点 强依赖数据库, 性能存在瓶颈 单库时使用方便,分库分表后就难受了 难以扩展 只能主库生成,单点故障了就gg了 数据库语法不同,迁移时需要考虑 容易泄密,比如订单号是递增的,那么可以猜到别人的订单号 3.2.3 MySQL设置自增的方式 只需设置主键自增即可,如下面的建表语句 CREATE TABLE `user` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT 'id', `name` varchar(64) NOT NULL COMMENT '名字', `nick_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '昵称', `create_time` datetime NOT NULL COMMENT '创建时间', `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci; 3.3 数据库集群模式 3.3.1 原理 数据库自增模式生成的唯一ID,当遇到分库分表场景时, ID则无法解决ID重复的问题，而且ID依赖于数据库，无法满足业务系统高并发以及高可用的需求．一种解决方案是使用数据库多主模式,也即数据库集群中每个实例都可以生成ID, 并且设置自增ID的起始值和步长 其原理图如下： 3.3.2 优缺点 优点 解决数据库自增模式下的单点故障问题以及性能问题 设置同样简单,只比数据库自增模式复杂一些 ID趋势自增，在同一数据库中是严格递增的 缺点 不利于后续扩容: 当我们在开始时设置步长为4时,这样每台数据库实例生成的ID如上图所示(图中下面方框中),但是随着业务增长,如果需要水平扩展数据库,即再增加一个数据库实例,这种情况下需将第5台实例的步长设置为5,第5台实例的起始位置要大于前4台实例中ID的最大值(预留部分,防止此段时间前4个实例中ID超过该值), 并且将前4台实例的步长修改为5. 而且还存在停机修改的可能性; 一种解决方案是初始时预留足够的步长,比如初始时有4台实例,但是设置步长可以为8,后续可水平扩展(当然缺点是单个实例ID耗尽速度*2) 强依赖数据库，同样存在性能问题. 如果是水平切分，如根据用户ID分库分表，那么某个分库挂了同样会影响可用性 3.3.3 MySQL设置起始值和步长的方法 实例1: set @@auto_increment_offset = 1; -- 起始值 set @@auto_increment_increment = 6; -- 步长 实例2: set @@auto_increment_offset = 2; -- 起始值 set @@auto_increment_increment = 6; -- 步长 实例3: set @@auto_increment_offset = 3; -- 起始值 set @@auto_increment_increment = 6; -- 步长 实例4: set @@auto_increment_offset = 4; -- 起始值 set @@auto_increment_increment = 6; -- 步长 3.4 数据库号段模式 3.4.1 原理 数据和本地缓存相结合的方式, 每个实例首先从数据库中取出一个ID的生成范围，然后需要使用时采用线程安全的方式从本地缓存的ID范围中取出即可,等实例内缓存的ID耗尽时再从数据库中取出一个ID生成范围 3.4.2 优缺点 优点 弱依赖数据库,每次从数据库中取出一个ID范围,提高了可用性和ID生成的性能. 即使生成ID的数据库挂了,实例中缓存的ID也能撑一段,而这段时间已经足够数据库恢复了(ID数据库和业务数据库是同一个数据库的话,就没用了) ID趋势递增 缺点 实例挂了, 则缓存的号段就丢失了 应用自身需保证线程安全, 可以采用AtomicLong的方式来保证 如果在号段耗尽后再去数据库取新的号段, 如果并发较高, 那么取号段的操作也会出现竞争严重的场景, 导致数据库压力较大, 一种解决方案是采用双buffer的方案, 即当第一个号段buffer1耗尽10%的时候, 开启一个线程取数据库中取号段缓存到另外一个buffer2中, 当第一个buffer1耗尽后能够立即切换到buffer2中; 不够随机, 订单场景不适用, 如果每天中午12点下单, 订单号相减能够大致推断出一天的订单量. 3.4.3 实现 号段模式可以有悲观锁和乐观锁两种实现, 这里我觉得两种方式都可以, 因为该唯一ID的生成方式就说明不会频繁的读写数据库,所以数据库的锁竞争不会很大, 乐观锁和悲观锁方式都可以应该都可以满足需求, 不过使用时还是需要按照具体的业务来设计. 3.4.3.1 乐观锁实现 CREATE TABLE id_generator ( id int(10) NOT NULL, max_id bigint(20) NOT NULL COMMENT '当前最大id', step int(20) NOT NULL COMMENT '号段的步长', biz_type int(20) NOT NULL COMMENT '业务类型', version int(20) NOT NULL COMMENT '版本号', PRIMARY KEY (`id`) ) 实例取ID的步骤: 从数据库中获取当前最大ID, SQL为: select max_id, step, version from id_generator where biz_type = '**'; 实例中设置ID范围范围为[max_id, max_id + step] 更新数据库中记录, SQL为: update table id_generator set max_id = max_id + step +1, version = version + 1 where biz_type = '**' and version = version(第一步中取出的); 如果第三步更新失败, 则说明发生冲突, 从第一步开始重试, 直到第三步成功; 3.4.3.2 悲观锁实现 CREATE TABLE id_generator ( id int(10) NOT NULL, max_id bigint(20) NOT NULL COMMENT '当前最大id', step int(20) NOT NULL COMMENT '号段的步长', biz_type int(20) NOT NULL COMMENT '业务类型', version int(20) NOT NULL COMMENT '版本号', PRIMARY KEY (`id`) ) 实例取ID的步骤: 开启事务; 从数据库中获取当前最大ID, SQL为: select max_id, step from id_generator where biz_type = '**' for update; 实例中设置ID范围范围为[max_id, max_id + step] 更新数据库中记录, SQL为: update table id_generator set max_id = max_id + step +1, version = version + 1 where biz_type = '**'; 提交事务 3.5 Redis/Zookeeper 采用中间件的方式, Redis和Zookeeper都可以实现, 不过Zookeeper我很少使用,这里不再讨论,其原理和Redis方式基本相同 3.5.1 Redis方式原理 3.5.1.1 强依赖redis方案 利用redis的 incr命令实现ID的原子性自增。 127.0.0.1:6379> set seq_id 1 // 初始化自增ID为1 OK 127.0.0.1:6379> incr seq_id // 增加1，并返回递增后的数值 (integer) 2 3.5.1.2 弱依赖redis方案 原理和数据库号段模式类似, redis中自增的是号段的起始值, 实例内缓存一个ID范围, 这里不再赘述. 3.5.2 优缺点 优点 实现简单 性能比数据库自增ID的方式要高 缺点 依赖redis, 系统需要引入中间件,增加了运维等成本; redis需考虑持久化, redis有两种持久化方式RDB和AOF. RDB会定时打一个快照进行持久化，假如连续自增但redis没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况; AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致Redis重启恢复的数据时间过长。 3.5.3 实现(redis自增模式的实现) 先设置RedisTemplate： @Bean public RedisTemplate getDefaultRedisTemplate(RedisConnectionFactory cf, RedisSerializer rs) { RedisTemplate redisTemplate = new RedisTemplate(); redisTemplate.setConnectionFactory(cf); redisTemplate.setDefaultSerializer(rs); redisTemplate.setKeySerializer(new StringRedisSerializer()); return redisTemplate; } 接下来实现ID生成逻辑： public long generate(String key,int increment) { RedisAtomicLong counter = new RedisAtomicLong(key, mRedisTemp.getConnectionFactory()); return counter.addAndGet(increment); } 3.6 雪花算法 Twitter公司开源的一种算法, 全局唯一并且趋势递增 3.6.1 原理 雪花算法生成的是8字节64bit长度的数字(long类型), 能够保证趋势递增的ID生成, 而且生成效率极高 雪花算法组成 第1位: 占用1bit，其值始终是0，保证生成的ID是正数; 第2- 42位: 时间戳, 占用41bit，精确到毫秒，总共可以容纳约69年的时间; 第43-52位: 工作机器id, 占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点; 第53-64位:序列号,占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。 SnowFlake算法在同一毫秒内最多可以生成的ID数量为: 1024 * 4096 = 4194304 3.6.2 优缺点 优点 基于时间戳，可以保证基本有序递增 不依赖第三方的库或者中间件, 在实例上生成, 可以保证高可用 生成效率极高, 满足高性能的要求 缺点 依赖机器时间, 如果发生时钟回退, ID可能重复 3.6.3 实现 /** * 雪花算法 * * @author Young * @Date 2021-05-22 17:04 */ public class SnowflakeIdGenerator { /** * 开始时间截 (这个用自己业务系统上线的时间) */ private static final long START_TIMESTAMP = 1575365018000L; /** * 机器id所占的位数 */ private static final long WORKER_ID_BITS_LENGTH = 10L; /** * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private static final long MAX_WORKER_ID = -1L ^ (-1L MAX_WORKER_ID || workerId 3.7 美团Leaf算法 推荐原系统的设计和开发者写的Leaf——美团点评分布式ID生成系统, 已经非常详细了, 小的就不再班门弄斧了 另外这篇也值得一看 Leaf：美团的分布式唯一ID方案深入剖析 美团Leaf算法有两种模式: segment模式: 即数据库号段模式, 优缺点在上文已经讨论过了; snowflake模式: 其主要有以下几点优化 解决时钟回退问题: 周期性上传实例时间戳到zookeeper中, 生成ID时获取的时间戳会与Zookeeper的时间戳比较, 但是并没有完全解决问题, 如果时钟回退超过5ms还是会抛出异常; 弱依赖zookeeper, 采用zookeeper持久化节点信息(即雪花算法中的实例节点信息), 但是引入zookeepery也是需要成本的 3.8 百度uid-generator UidGenerator UidGenerator：百度开源的分布式ID服务（解决了时钟回拨问题） 百度开源分布式id生成器uid-generator源码剖析 百度uid-generator也是类snowflake算法, 其主要特点有: 调整雪花算法的位数, 机器节点数增大 弱依赖时间戳, 采用当前时间(秒)和系统上线时间的差值 加入缓存机制, 更高的性能 实例信息从数据库中获取, 每次重启实例序号 + 1 3.9 TinyId TinyId 滴滴开源的Tinyid如何每天生成亿级别的ID？ Tinyid是用Java开发的一款分布式id生成系统，基于数据库号段算法实现, 简单来说是数据库中保存了可用的id号段，tinyid会将可用号段加载到内存中，之后生成id会直接内存中产生。 可用号段在第一次获取id时加载，如当前号段使用达到一定量时，会异步加载下一可用号段，保证内存中始终有可用号段。(如可用号段1~1000被加载到内存，则获取id时，会从1开始递增获取，当使用到一定百分比时，如20%(默认)，即200时，会异步加载下一可用号段到内存，假设新加载的号段是1001~2000,则此时内存中可用号段为200~1000,1001~2000)，当id递增到1000时，当前号段使用完毕，下一号段会替换为当前号段。依次类推。 TinyId的主要特点有: 采用数据库号段模式 使用了双缓存的逻辑 多DB支持(数据库集群模式) 4 分布式ID生成方案总结 分布式ID生成方案大致分为2种, 一是基于数据库或者redis的生成方案, 二是类雪花算法生成方案 雪花算法生成方案中, 存在时钟回退问题, 时钟回退的问题可以使用记录下上次生成的时间戳(引入数据库或者中间件), 当生成ID时对比下当前时间和记录的时间戳, 如果发生时钟回退,那么抛出异常或者将阻塞等待. 数据库或者redis的生成方案中, 存在难以扩展和数据库性能问题, 衍生出数据库集群模式的方案和号段模式的方案, 号段模式为了防止耗尽时的高并发, 一般采用双缓存的解决方案. 5 参考资料 分布式ID之UUID适合做分布式ID吗 UUID/GUID介绍、生成规则及生成代码 分布式唯一 ID 生成方案，有点全！ 分布式唯一ID生成方案 一口气说出9种分布式ID生成方式，面试官有点懵了 这可能是讲雪花算法最全的文章 分布式ID神器之雪花算法简介 Leaf——美团点评分布式ID生成系统 UidGenerator UidGenerator：百度开源的分布式ID服务（解决了时钟回拨问题） 百度开源分布式id生成器uid-generator源码剖析 TinyId 滴滴开源的Tinyid如何每天生成亿级别的ID？ powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "},"IO模型/IO模型.html":{"url":"IO模型/IO模型.html","title":"IO模型","keywords":"","body":"操作系统IO过程 应用程序发起的一次IO操作包含两个阶段： IO调用：应用程序进程向操作系统内核发起调用 IO执行：操作系统内核完成IO操作 操作系统内核完成IO操作还包括两个过程： 准备数据阶段：内核等待IO设备准备好数据 拷贝数据阶段：将数据从内核缓冲区拷贝到用户空间缓冲区 一个完整的IO过程包括以下几个步骤： 应用程序进程向操作系统发起IO调用请求 操作系统准备数据，把IO外部设备的数据加载到内核缓冲区 操作系统拷贝数据，即将内核缓冲区的数据拷贝到进程缓冲区中 IO模型 下述所说应用程序，应用进程，应用线程，如无特殊说明都是一个意思 概念 同步与异步 同步与异步关注的是消息通知机制。 所谓同步即实在发出一个调用时，在没有等到结果之前，该调用就不返回，一旦调用返回就得到了返回值。也就是调用者主动等待这个调用结果。 异步和同步相反，调用在发出之后，调用立即就返回，没有调用结果。如果调用者要得到结果，必须主动的查询被调用者状态或者被调用者通过通知、回调通知调用者。调用者主动查询，那么调用者一般是定期来查询，效率较低。如果使用通知和回调的方式，效率较高。 阻塞和非阻塞 阻塞和非阻塞关注的是程序在等待调用结果时的状态 阻塞调用是指调用结果返回之前，调用者线程会被挂起。 非阻塞调是指调用结果返回之前，调用者线程不会被挂起。 阻塞IO(Block IO) 假设应用程序的进程发起IO调用，但是操作系统的内核的数据还没准备好，那么应用程序就一直在阻塞等待，直到内核的数据就绪并且操作系统将内核态的数据拷贝到用户态之后才返回调用结果，应用程序线程在得到内核的返回之后才继续执行。这种IO操作称为阻塞IO。 阻塞IO是最流行的IO模型,简称BIO，比较经典的应用就是阻塞socket、Java BIO。 阻塞IO的缺点就是：如果内核数据一直没准备好，那么用户进程/线程将一直阻塞，消耗资源。 非阻塞IO(Non-Blocking IO) 如果应用程序请求调用后，内核数据未就绪前，可以先返回错误信息给应用程序，调用程序不用挂起，通过不断轮询的方式再来请求。这就是非阻塞IO。 非阻塞IO，简称NIO。相对于阻塞IO，虽然大幅提高了性能，但是该种方式仍然存在性能问题，即频繁的轮询操作，这将导致频繁的系统调用，同样消耗大量的CPU资源。通常在专门提供某一功能的系统中才会使用 IO多路复用 非阻塞IO的轮询发起recvfrom系统调用，直到操作系统内核的数据就绪，导致消耗CPU资源。因此IO多路复用模型优化的思想将轮询内核数据是否准备好的操作交由系统线程去做(之前由应用程序轮询)，等到内核中的数据准备好了之后，主动通知应用进程，应用程序再去进行recvfrom系统调用。 IO复用模型的核心思路是：系统提供一类函数(select, poll, epoll), 该类函数能够监控多个文件描述符(fd, file descriptor), 任何一个返回内核数据就绪，应用进程再发起recvfrom系统调用。 文件描述符(fd, file descriptor)： linux一切皆文件，当程序打开一个或者创建一个新文件时，内核会向进程返回一个文件描述符，包括接收网络数据。 IO多路复用-select 应用程序通过调用select函数，可以同时监控多个文件描述符，在select函数监控的文件描述符中，只要有任何一个数据状态准备就绪了，select函数就会返回可读状态，这时应用程序再发起recvfrom系统调用去获取数据。 非阻塞IO模型中，应用程序需要不断的轮询系统调用(recvfrom)，但是select的IO多路复用模型，只需要发起一次系统调用就够了，减少了系统调用的次数, 优化了性能。 但是select有几个缺点： 监听的IO最大连接数有限，在linux系统上一般为1024 select函数内部维护了一个文件描述符的list(数组)，通过遍历该数组找到就绪的文件描述符，效率较低 IO多路复用-poll 解决了select连接数有限的缺点。其内部同样维护了一个文件描述符的list(链表)，仍然采用遍历的方式找到就绪的文件描述符，效率同样较低 IO多路复用-epoll epoll是为了解决select/poll的问题：查找就绪文件描述符效率低的问题，其采用事件驱动来实现的 epoll先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。select/poll查找文件描述的时间复杂度为O(n), epoll去掉了遍历文件描述符数组的过程，采用回调的方式，效率更高，不过实现逻辑更加复杂了(我们也不管，操作系统实现的，哈哈) select、poll、epoll区别 select poll epoll 底层数据结构 数组 链表 红黑树和双链表 获取就绪的文件描述符 遍历 遍历 回调 时间复杂度 O(n) O(n) O(1) 最大连接数 有限制(1024) 无限制 无限制 数据拷贝 每次调用select，需要将fd数据从用户空间拷贝到内核空间 每次调用poll，需要将fd数据从用户空间拷贝到内核空间 使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间 信号驱动模型 IO多路复用，将询问内核数据是否准备好的工作交由一个单独线程去做，但是应用程序仍然是阻塞于该“询问线程的”。而信号驱动模型不再阻塞该“询问线程”。 信号驱动IO不再主动询问的方式去确认数据是否就绪，而是向内核发送一个信号(调用sigaction)的时候建立一个SIGIO信号), 然后应用进程可以去做别的事，不用阻塞。当内核数据准备好之后，再通过SIGIO信号通知应用进程内核数据已准备就绪。应用程序收到信号后，再调用recvfrom系统调用去读取数据。 信号驱动IO模型，在应用进程发出信号后，是立即返回的，不会阻塞进程。它已经有异步操作的感觉了。但是你细看上面的流程图，发现数据复制到应用缓冲的时候，应用进程还是阻塞的。回过头来看下，不管是BIO，还是NIO，还是信号驱动，在数据从内核复制到应用缓冲的时候，都是阻塞的。 异步IO(AIO) 前面讲的BIO，NIO和信号驱动，在数据从内核复制到应用缓冲的时候，都是阻塞的，因此都不是真正的异步。AIO实现了IO全流程的非阻塞，就是应用进程发出系统调用后，是立即返回的，但是立即返回的不是处理结果，而是表示调用成功类似的意思。等内核数据准备好，将数据拷贝到用户进程缓冲区，发送信号通知用户进程IO操作执行完毕。 异步IO的优化思路很简单，只需要向内核发送一次请求，就可以完成数据状态询问和数据拷贝的所有操作，并且不用阻塞等待结果。 总结 网络IO 参考 如何理解阻塞、非阻塞与同步、异步的区别 JavaIO模型 100%弄明白5种IO模型 看一遍就理解：IO模型详解 五种IO模型介绍和对比 极客时间:Java性能调优实战-刘超 powered by GitbookYoung, 该文件最后修改时间： 2022-07-26 21:59:21 "},"jvm/readme.html":{"url":"jvm/readme.html","title":"JVM","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2022-08-01 12:39:25 "},"jvm/JVM运行时数据区.html":{"url":"jvm/JVM运行时数据区.html","title":"JVM运行时数据区","keywords":"","body":"JVM运行时数据区 JVM运行机制 JVM是用于运行Java字节码的虚拟机，包括字节码指令集、程序寄存器、虚拟机栈、虚拟机堆、方法区和垃圾回收器。JVM屏蔽了操作系统的差异，能够跨平台运行，其运行在操作系统之上，不与硬件系统直接交互。 Java源文件(.java)在通过编译器之后被编译成相应的字节码文件(.class)，字节码文件又被JVM中的解释器编译成机器码后在操作系统上运行。每种操作系统的解释器都是不同的。 如上图所示，JVM包括一个类加载器子系统、运行时数据区、执行引擎和本地接口库。本地接口库通过调用本地方法库与操作系统交互。 下面我们将依次说明对JVM各组成部分的关键知识点 JVM的内存区域 JVM的内存区域分为线程私有（虚拟机栈、程序计数器、本地方法栈），线程共享（堆、方法区）和直接内存 线程私有区域的生命周期与线程相同，每个线程都与操作系统的本地线程直接映射。 线程共享区域随虚拟机的启动而创建，随虚拟的关闭而销毁。 直接内存也叫做堆外内存、其并不是JVM运行时数据区的一部分，但是JVM内存区域的重要组成部分。Java通过堆外内存避免在Java堆和Native堆中来回复制数据带来的资源浪费和性能消耗，因此堆外内存在高并发应用场景下被广泛使用(JavaNIO, Netty) 程序计数器 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。 如果该方法执行的是native方法，那么程序计数器的值为空(Undefined) 程序计数器属于线程私有的内存区域，唯一一个没有内存溢出(Out Of Memory)的区域 程序计数器主要有两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 虚拟机栈 虚拟机栈是描述Java方法的执行过程的内存模型，由栈帧组成。当前栈帧中存储了本地变量表，操作数栈、动态链接和方法出口等信息。同时栈帧用来存储部分运行时数据及其数据结构，处理动态链接方法的返回值和异常分发。 栈帧用来记录方法的执行过程，在方法被执行时虚拟机会为其创建一个与之对应的栈帧，方法的执行和返回对应栈帧在虚拟机栈中的入栈和出栈，每个运行中的线程只有一个栈帧处于活动状态。 Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， 栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。 程序运行中栈可能会出现两种错误： StackOverFlowError： 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。 OutOfMemoryError： 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 局部变量表 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。 操作数栈 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。 动态链接 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。 本地方法栈 本地方法栈和虚拟机栈的作用类似，区别是虚拟机栈执行的是Java方法，而本地方法栈则执行的是Native方法。在HotSpot虚拟机中本地方法栈和Java虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。 堆 Java虚拟机管理的内存中最大的一块，Java堆是所有线程共享的一块内存区域，在JVM启动时创建。几乎所有的对象实例和数组都在堆上分配内存。但是随着JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配和标量替换优化技术将会导致一些微妙的变化，有些对象不一定会在堆上分配内存。从JDK1.7开始默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用，那么对象可以直接在栈上分配内存。 Java堆也被成为GC堆(垃圾回收器的主要区域)，从垃圾回收器的角度可以细分为：新生代、老年代和永久代。划分的目的的是使用分代收集算法。 Java堆中最容易出现的是OutOfMemoryError错误： java.lang.OutOfMemoryError: GC Overhead Limit Exceeded ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。 java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。 新生代(Young Generation) JVM创建的对象(除大对象)会被存放在新生代，默认占1/3的堆内存空间。由于JVM会频繁的创建对象，所以新生代会频繁出发MinorGC进行垃圾回收。新生代又分为Eden区，SurvivorTo和SurvivorFrom区。 Eden区(8/10的堆空间)：Java新创建的对象首先会被存储在Eden区，如果新创建的对象属于大对象，则直接将其分配到老年代。大对象的定义和具体的JVM版本、堆大小和垃圾回收策略有关，一般为2KB~128KB，可通过XX:PretenureSizeThreshold设置其大小。在Eden区空间不足时会出发MinorGC. SurvivorTo(1/10的堆空间): 保留上一次MinorGC时的幸存者 SurvivorFrom(1/10的堆空间)：将上一次MinorGC时的幸存者作为这一次MinorGC的被扫描者。 新生代GC叫做MinorGC，采用复制算法，简略过程如下： 对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入Survivor区并且对象年龄+1 SurvivorFrom区经历N次垃圾回收的对象，进入到SurvivorTo区。对象晋升年龄由XX:MaxTenuringThreshold设置，默认15 SurvivorFrom区 SurvivorTo区和SurvivorFrom区互换，原来的SurvivorTo区成为下一次GC的SurvivorFrom区。 老年代(Old Generation) 老年代主要存放长生命周期的对象和大对象，默认占2/3的堆空间。老年代的GC过程叫做MajorGC。老年代的对象比较稳定，MajorGC并不会频繁触发。在进行MajorGC前，JVM会进行一次MinorGC，在MinorGC过后仍然出现老年代空间不足时会触发MajorGC。 MajorGC采用标记清楚算法。进行GC时要扫描老年代的所有对象再回收，所以MajorGC的耗时会比较长。标记清楚算法会产生内存碎片 永久代(Permanent Generation) 方法区、永久代和元空间的关系：方法区是JVM中规定的概念，永久代是JDK1.8之前的实现，JDK1.8之后其实现是元空间 方法区是线程共享的内存区域，其存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量，即时编译时编译器编译后的代码缓存等数据。 为什么JDK1.8使用原空间替代永久代： 整个永久代有一个JVM本身设置的固定大小上限，无法进行调整，而元空间使用的直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小，其出现内存不足的错误为：java.lang.OutOfMemoryError: MetaSpace。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由MaxPermSize(最大堆内存)控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。 // JDK1.8之前 -XX:PermSize=N //方法区 (永久代) 初始大小 -XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen // JDK1.8之后 -XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小） -XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小 运行时常量池 Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 常量池表(Constant Pool Table) 。 字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量，符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。 常量池表会在类加载后存放到方法区的运行时常量池中。 运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。 字符串常量池 字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。 HotSpot 虚拟机中字符串常量池的实现是 src/hotspot/share/classfile/stringTable.cpp ,StringTable 本质上就是一个HashSet ,容量为 StringTableSize（可以通过 -XX:StringTableSize 参数来设置）。 StringTable 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。 JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。 JDK 1.7 为什么要将字符串常量池移动到堆中？ 主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。 直接内存 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。 JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。 本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。 参考 JavaGuide powered by GitbookYoung, 该文件最后修改时间： 2022-08-07 10:04:11 "},"jvm/类文件结构.html":{"url":"jvm/类文件结构.html","title":"类文件结构","keywords":"","body":"Java类文件结构 字节码文件结构 .java格式的Java源代码被编译后输出.class 格式的字节码，字节码是JVM能够理解的代码。Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且由于字节码并不针对一种特定的机器，因此，Java程序无需重新编译便可在多种操作系统的计算机上运行。 不用语言写成的源代码只要能够编译成字节码的格式并且满足JVM虚拟机的规范，就可以运行在JVM上，如Groovy、Scala和Ruby等语言。 Class文件是以8字节为基础的字节流构成的，其采用了类似C语言的结构体来存储数据，主要有2类数据项：无符号数和表。无符号数用来表述数字、索引引用以及字符串等，u1、u2、u4分别代表1个、2个4个字节的无符号数。表是有多个无符号数以及其他的表组成的复合结构。 根据虚拟机规范，Class文件通过ClassFile定义，有点类似C语言的结构体。 ClassFile的结构如下： ClassFile { u4 magic; // 魔数，Class文件的标志 u2 minor_version; // Class文件的小版本号 u2 major_version; // Class文件的大版本号 u2 constant_pool_count; // 常量池的数量 cp_info constant_pool[constant_pool_count-1]; // 常量池 u2 access_flags; // Class的访问标记 u2 this_class; // 当前类 u2 super_class; // 父类 u2 interfaces_count; // 接口数量 u2 interfaces[interfaces_count]; // 接口 u2 fields_count; // 字段数量 field_info fields[fields_count]; // 字段 u2 methods_count; // 方法数量 method_info methods[methods_count]; // 方法 u2 attributes_count; //属性数量 attribute_info attributes[attributes_count]; // 属性 } 魔数 u4 magic; // 魔数，Class文件的标志 u2 minor_version; // Class文件的小版本号 每个Class文件的前4个字节成为魔数(magic number)，其作用是确定这个文件是否是一个能够被虚拟机接受的Class文件，JVM每次都会先检查魔数的值是否为0xCAFEBABE，如果不是此固定值，那么JVM会停止加载。 如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出以下错误： Error: A JNI error has occurred, please check your installation and try again Exception in thread \"main\" java.lang.ClassFormatError: Incompatible magic value 1885430635 in class file StringTest Class文件版本号 u2 minor_version; // Class文件的小版本号 u2 major_version; // Class文件的大版本号 魔数后面的4个字节存储的Class文件的版本号，其中第五和第六位是小版本号，第七和第八位为主版本号。它们共同构成了class文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个Class 文件的格式版本号就确定为 M.m 每当Java发布大版本的时候(Java8、Java9这种)，主版本号就会+1。Java 的版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号向上加1。可以使用javap -v命令来快速查看Class文件的版本号信息。 高版本的Java虚拟机可以执行低版本的编译器生成的Class文件，但是低版本的Java虚拟机不能执行高版本编译器生成的Class文件，如果低版本的Java虚拟机执行了高版本的编译器生成的Class文件，会报错class file has wrong version 50.0, should be 49.0 在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的JDK版本和生产环境中的JDK版本是否一致。 常量池 u2 constant_pool_count; // 常量池的数量 cp_info constant_pool[constant_pool_count-1]; // 常量池 常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的无符号数，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的, 将第0项常量空出来是有特殊考虑的，索引值为0代表不引用任何一个常量池项。 常量池中每一个常量都是一个表，这14种表有一个共同的特点：开始的第一位是一个u1类型的标志位————tag来标识常量的类型，代表当前这个常量是属于哪种类型的常量类型。 类型 标志(tag) 描述 CONSTANT_utf8_info 1 UTF8编码的字符串 CONSTANT_Integer_info 3 整形字面量 CONSTANT_Float_info 4 浮点型字面量 CONSTANT_Long_info 5 长整型字面量 CONSTANT_Double_info 6 双精度字面量 CONSTANT_Class_info 7 类或接口的符号引用 CONSTANT_String_info 8 字符串类型的字面量 CONSTANT_Fieldref_info 9 字段的符号引用 CONSTANT_Methodref_info 10 类中方法的符号应用 CONSTANT_InterfaceMethodref_info 11 接口中方法的符号引用 CONSTANT_NameAndType_info 12 字段或方法的符号引用 CONSTANT_MethodType_info 16 标志方法类型 CONSTANT_MethodHandle_info 15 表示方法句柄 CONSTANT_InvokeDynamic_info 18 表示一个动态方法调用点 字面量和符号引用 常量池主要存放的是: 字面量和符号引用。字面量比较接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等。符号引用则属于编译原理方面的概念，包括有三类常量：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。 全限定名 com/jvm/test/Demo这个就是类的全限定名，仅仅是把包名的“.“替换成”/”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。 简单名称 简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的add()方法和num字段的简单名称分别是add和num。 描述符 描述符：描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，详见下表。描述符在常量池中使用CONSTANCE_Utf8_info表示 标识符 含义 B 基本数据类型byte C 基本数据类型char D 基本数据类型double F 基本数据类型float I 基本数据类型int J 基本数据类型long S 基本数据类型short Z 基本数据类型boolean V 代表void L 代表对象类型，如Ljava/lang/Object; [ 代表数组，如double[]表示为[D 在描述符来描述方法时，按照先参数列表后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号内，如： java.lang.String toString() 方法描述符为 ()Ljava/lang/String; int abc(int[] x, int y) 方法描述符为([II)I 虚拟机在加载Class文件时才会进行动态链接，也就是说Class文件中不会保存各个方法和字段的最终内存布局信息。因此这些字段和方法的符号引用不经过转换时无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局有关，引用的目标并不一定已经加载到内存中。 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。 常量类型和结构 这14种表的共同点：表开始的第一位是一个u1类型的标志位, 代表当前这个常量项使用的是哪一种表结构 在常量池列表中，CONSTANCE_Utf8_info常量项是一种使用改进过UTF8编码格式来存储诸如文字字符串、类或者接口全限定名、字段或者方法的简单名称以及描述符等常量字符串信息，其大小由length决定。因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才能确定，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不确定，编译后通过utf8编码才可以直到其长度 访问标志(Access Flag) u2 access_flags; // Class的访问标记 访问标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是否为public或者abstract类型，类的声明是否为final等等。 标志名称 标志值 含义 ACC_PUBLIC 0x0001 标志为public,可以在外部访问 ACC_FINAL 0x0010 标志为final，不可以有子类 ACC_SUPER 0x0020 标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为true(使用增强的方法调用父类的方法) ACC_INTERFACE 0X0200 标志这是一个接口 ACC_ABSTRACT 0x0400 是否为abstract类型，对于接口或者抽象类来说，此标志位为true，其他类型为false ACC_SYNTHETIC 0x1000 标志此类并非由用户代码产生(由编译器产生的类，没有源码对应) ACC_ANNOTATION 0x2000 标志这时一个注解 ACC_ENUM 0x4000 枚举类 类的访问权限通常为ACC_开头的常量 每一种类型的表示都是通过设置访问标记的32的特定位来实现的，比如pubic final的类，则该标记为ACC_PUBLIC|ACC_FINAL. ACC_SUPER可以让类更准确地定位到父类的方法super.method， 现代编译器都会设置并使用这个标志。 ACC_INTERFACE标志的是接口而不是类，反之则表示的是类而不是接口 如果一个class文件被设置了ACC_INTERFACE标志，那么同时也得设置ACC_ABSTRACT标志。同时不能被设置为ACC_FINAL、ACC_SUPER或ACC_ENUM标志。 如果没有设置ACC_INTERFACE标志，那么这个class文件可以具有上表中除ACC_ANNOTATION外的其他所有标志。当然，ACC_FINAL和ACC_ABSTRACT这类互斥的标志除外。 ACC_SUPEr标志用于确定类或接口里面的invokespecial指令使用的是哪一种执行语义。针对Java虚拟机指令集的编译器都应当设置这个标志。对于JavaSe8及以后的版本来说，无论class文件中这个标志的实际值是什么，也不管class文件的版本号是多少，Java虚拟机都认为每个class文件均设置了ACC_SUPER标志。ACC_SUPER标志是为了向后兼容由旧的Java编译器所编译的代码而设计的。目前的ACC_SUPER标志在由JDK1.0.2之前的编译器所生成的access_flag中没有确定含义，如果设置了该标志，那么Oracle的JVM实现会将其忽略。 ACC_SYNTHETIC标志意味着该类或者接口是有编译器生成的，而不是由源代码生成的。 注解类型必须设置ACC_ANNOTATIOON标志。如果设置了ACC_ANNOTATION标志，那么也必须设置ACC_INTERFACE标志。 ACC_ENUM标志表明该类或其父类为枚举类型 类索引、父类索引、接口索引集合 u2 this_class; // 当前类 u2 super_class; // 父类 u2 interfaces_count; // 接口数量 u2 interfaces[interfaces_count]; // 接口 长度 含义 说明 u2 this_class 2字节无符号整数，指向常量池的索引，提供了类的全限定名，其值必须是对常量池表中某一项的有效索引值。常量池在这个索引处的项必须是CONSTANT_Class_info u2 super_class 2字节无符号整数，指向常量池的索引，提供了父类的全限定名。如果没有继承任何类，其默认继承的是java/lang/Object类，同时Java不支持多继承，所以其父类只有一个。super_class不能是final的 u2 interfaces_count 当前类或接口的直接实现的接口数量 u2 interfaces[interfaces_count] 每个成员的值必须是对常量池中某项的有效索引，长度为interfaces_count，每个成员都必须为CONSTANCT_Class_info结构。在interfaces[]中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即interfaces[0]对应的是源代码中最左边的接口 字段表集合 u2 fields_count; // 字段数量 field_info fields[fields_count]; // 字段 字段表用来描述接口或者类中声明的变量。字段(field)包括类级变量以及实例级变量，但是不包括方法内部、代码块内部声明的局部变量。字段叫什么名字、字段被定义为什么数据类型，这些都是在编码阶段才能知道的，所以其只能引用常量池的常量来描述。字段表指向常量池索引集合，描述了每个字段的完整信息。比如字段的标志符、访问修饰符、类变量or实例变量，是否是常量等。 字段表集合中不会出现从父类或者实现的接口中继承而来的字段，但是由可能列出原本Java代码之中不存在的字段。比如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。 在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名字，但是对于字节码来说，如果两个字段的描述符不一致，那字段重名就是合法的。 字段计数器fields_count fields_count的值表示当前class文件fields表的成员个数，使用两个字节表示。 字段表field_info[] 字段表中每个成员都是一个field_info结构，用于表示该类或接口中所声明的类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口中继承的字段。 一个字段包括如下信息： 作用域(public、private、proteced修饰符等) 是实例变量还是类变量(static修饰符) 可变性(final) 并发可见性(volatile修饰符) 是否序列化(transient修饰符) 字段数据类型(基本数据类型、对象、数组) 字段名称 字段表的结构如下： field_info { u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count]; } 字段访问标识 access_flags 一个字段可以被各种关键字修饰，比如：作用域(public、private、protected)、static修饰符、final修饰符、volatile修饰符。因此，可以像类一样，使用一些标记来标记字段。字段的访问标记有： 标志名称 标志值 含义 ACC_PUBLIC 0x0001 字段是否为public ACC_PRIVATE 0x0002 字段是否为private ACC_PROTECTED 0x0004 字段是否为protected ACC_STATIC 0x0008 字段是否为static ACC_FINAL 0x0010 字段是否为final ACC_VOLATILE 0x0040 字段是否为volalite ACC_TRANSTENT 0x0080 字段是否为transtent ACC_SYNTHETIC 0x1000 字段是否是编译器自动生成的 ACC_ENUM 0x4000 字段是否为枚举类型 字段名索引name_index 根据字段名索引的值，查询常量池中的制定索引项即可，指向的是常量池表中的CONSTANT_Utf8_info 描述符索引descriptor_index 描述符的作用是用来描述字段的数据类型。 详见上节描述符 属性表数量attributes_count 表示属性表的数量 属性表数组attributes[attributes_count] 一个字段还可能拥有一些属性，用于存储更多的额外信息，比如初始值、一些注释等。属性的具体内容存放在熟悉性表中。 对于常量属性而言，attributes值恒为2，详见属性表 方法表 u2 methods_count; // 方法数量 method_info methods[methods_count]; // 方法 在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符(public、private、protected)，方法的返回值类型以及方法的参数信息等。方法表只描述当前类或接口中声明的方法，不包括从父类或父接口中继承的方法。方法表中可能会出现编译器自动添加的方法，如类初始化方法和实例初始化方法, 方法表中不会体现native方法和抽象方法。 在Java中，如果要重载(overload)一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用集合，也就是因为返回值不会包含在特征签名中，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但是在Class文件合适中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存，也就是说，如果两个方法由相同的名称和特征签名，但是返回值不同，那么也是可以合法共存于同一个class文件中的。也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是在字节码文件中却允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。 method_count的值表示当前class文件methods表的成员个数，使用2个字节表示。method表中每个成员都是method_info结构，用于表示当前类或接口中某个方法的完成描述。如果某个method_info结构的access_flags项非ACC_NATIVE和ACC_ABSTRACT，那么该结构中页应该包含实现这个方法所用的Java虚拟机指令。method_info可以表示类或者接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口的初始化方法，其结构如下： method_info { u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count]; } method_info和field_info结构类似，这里不再赘述，只说明下method_info中的方法访问标志 方法访问标志access_flags 标志名 标志值 解释 ACC_PUBLIC 0x0001 public修饰的方法 ACC_PRIVATE 0x0002 private修饰的方法 ACC_PROTECTED 0x0004 protected修饰的方法 ACC_STATIC 0x0008 static修饰的方法 ACC_FINAL 0x0010 final修饰的方法，子类不可以重写 ACC_SYNCHRONIZED 0x0020 synchronized修饰的方法 ACC_BRIDGE 0x0040 bridge方法，编译器自动生成的 ACC_VARARGS 0x0080 可变的参数的方法 ACC_NATIVE 0x0100 native方法 ACC_ABSTARCT 0x0400 abstact方法 ACC_STRICT 0x0800 声明为srtictfp，方法中浮点类型的变量都采用严格的浮点计算 ACC_SYNTHETIC 0x1000 编译器自动生成的方法 属性表 u2 attributes_count; //属性数量 attribute_info attributes[attributes_count]; // 属性 属性表中指的是class文件所附带的辅助信息，比如该class文件的源文件名字，以及任何带有RetentionPolicy.CLASS或者RetentionPolicy.RUNTIME的注解。此外字段表、方法表都可以有自己的属性表，用于描述某些场景专有的信息。属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己的属性信息，但是JVM通常会忽略掉不认识的属性。 attributes_count表示的是当前class文件的属性表的个数，属性表中每个成员都是attribute_info结构。 attribute_info { u2 attribute_name_index; // 属性名索引 u4 attribute_length; // 属性长度 u1 info[attribute_length]; // 属性表 } Attribute ConstantValue Code StackMapTable Exceptions InnerClasses EnclosingMethod Synthetic Signature SourceFile SourceDebugExtension LineNumberTable LocalVariableTable LocalVariableTypeTable Deprecated RuntimeVisibleAnnotations RuntimeInvisibleAnnotations RuntimeVisibleParameterAnnotations RuntimeInvisibleParameterAnnotations RuntimeVisibleTypeAnnotations RuntimeInvisibleTypeAnnotations AnnotationDefault BootstrapMethods MethodParameters Code Attribute Code_attribute { u2 attribute_name_index; // 属性名索引 u4 attribute_length; // 属性长度 u2 max_stack; // 操作数栈最大深度 u2 max_locals; // 局部变量表所需的存续空间 u4 code_length; // 字节码指令长度 u1 code[code_length]; // 存储字节码指令的数组 u2 exception_table_length; // 异常表长度 { u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; } exception_table[exception_table_length]; // 异常表 u2 attributes_count; // 属性集合计数器 attribute_info attributes[attributes_count]; // 属性集合 } 字节码查看工具 jclasslib jclasslib javap javap 是 JDK 自带的反解析工具。它的作用就是根据 Class 字节码文件，反解析出当前类对应的 Code 区(字节码指令)、局部变量表、异常表和代码行偏移量映射表、常量池等信息 aba@xxl:~$ javap --help 用法: javap 其中, 可能的选项包括: -help --help -? 输出此用法消息 -version 版本信息 -v -verbose 输出附加信息 -l 输出行号和本地变量表 -public 仅显示公共类和成员 -protected 显示受保护的/公共类和成员 -package 显示程序包/受保护的/公共类 和成员 (默认) -p -private 显示所有类和成员 -c 对代码进行反汇编 -s 输出内部类型签名 -sysinfo 显示正在处理的类的 系统信息 (路径, 大小, 日期, MD5 散列) -constants 显示最终常量 -classpath 指定查找用户类文件的位置 -cp 指定查找用户类文件的位置 -bootclasspath 覆盖引导类文件的位置 javac -g 解析字节码文件得到的信息中，有些信息(如局部变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等等)需要在使用 javac 编译成 Class 文件时，指定参数才能输出,比如，你直接 javac xx.java，就不会在生成对应的局部变量表等信息，如果你使用 javac -g xx.java 就可以生成所有相关信息了。如果你使用的 Eclipse 或 IDEA，则默认情况下，Eclipse、IDEA 在编译时会帮你生成局部变量表、指令和代码行偏移量映射表 参考 JVM18虚拟机的基石:Class文件 Java SE8 类文件结构详解 powered by GitbookYoung, 该文件最后修改时间： 2022-08-07 15:49:56 "},"jvm/类加载.html":{"url":"jvm/类加载.html","title":"类加载","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2022-08-07 10:04:11 "},"jvm/JVM对象.html":{"url":"jvm/JVM对象.html","title":"JVM对象","keywords":"","body":"JVM对象 JVM对象创建 类加载检查 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有则必须执行类加载过程。 分配内存 在类检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定下来，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。 内存分配方式包括：指针碰撞和空闲列表，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 指针碰撞 使用场合：堆内存规整，也即没有内存碎片的情况下 原理：用过的内存全部整合到一边，没有用过的内存放在另外一边，中间有一个分界指针，只需要向着没有用过的内存方向将该指针移动对象内存大小位置即可。 使用该分配方式的GC收集器Serial, ParNew 空闲列表 使用场合：堆内存不规整的情况 原理：虚拟机会维护一个列表，该列表会记录哪块内存是可用的，在分配的时候，找一块足够大的内存块来划分给对象实例，最后更新列表记录 使用该分配方式的GC收集器：CMS 选择以上两种方式中的哪一种，取决于Java堆内存是否规整。而Java堆内存是否规整，取决于GC收集器的算法是“标记-清除”还是“标记-整理”，“复制算法”的内存也是规整的。 内存分配并发问题 在创建对象的时候有一个很重要的问题，就是线程安全的问题。在实际开发过程中，创建对象是很繁琐的事情，作为虚拟机来说，必须要保证线程是安全的，通常来说虚拟机采用两种方式来保证线程安全： CAS+失败重试：CAS是乐观锁的一种实现方式。所谓乐观锁就是假设不存在冲突，如果存在冲突就失败重试，直到成功为止。虚拟机采用CAS+失败重试的方式保证更新操作的原子性。 TLAB表: 为每一个线程预先在Eden区上分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB表上分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。 初始化零值 内存分配完成后，虚拟机需要将分配的内存空间都初始化为零值(不包括对象头)，这一步操作保证了实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 设置对象头 初始化零值完成之后，虚拟机要对归降进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象头中。另外虚拟机根据当前的运行状态的不同，对象头会有不同的设置方式，如是否启用偏向锁。 执行inin方法 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角看，对象创建才刚开始，方法还没有执行，所有的字段都还为零。所以一般来说，执行new指令之后才会接着执行 方法，把对象按照从程序员的意愿进行初始化，这样一个真正的对象才算完全产生出来。 对象的内存布局 在Hotspot虚拟机中，对象在内存中的布局可以分为：对象头、实例数据和对齐填充。 Hotspot虚拟机的对象头包括两部分：第一部分用于存储对象自身的运行时数据(哈希码、GC分代年龄、锁状态标志等等)，另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。 对齐填充部分不是必然存在的，也没有特殊的含义，仅仅起占位作用。因为Hotspot虚拟机的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分是8字节的整数倍(1倍或2倍) ，因此，当对象的实例数据部分没有对齐时，就需要通过对齐填充来补全。 对象的访问定位 建立对象就是为了使用对象，我们的Java程序通过栈上的reference数据来操作堆上的具体对象。对象的访问方式由虚拟机的实现而定，目前主流的访问方式有：使用句柄和直接指针 句柄 如果使用句柄，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 直接指针 如果使用直接指针访问，那么Java堆对象的布局就必须考虑如何放置访问类型数据的相关信息，而reference中存储的就是对象的地址。 比较 两种对象访问方式各有优势。如果使用句柄来访问的最大好处时reference中存储的是稳定的句柄地址，在对象被移动时只需要改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针的访问方式最大的好处是速度快，节省了一次指针定位的时间开销。 Hotspot主要使用的是直接指针的方式来进行对象的访问。 powered by GitbookYoung, 该文件最后修改时间： 2022-08-07 10:04:11 "},"jvm/JVM_GC.html":{"url":"jvm/JVM_GC.html","title":"JVM垃圾回收","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2022-08-07 10:04:11 "},"jvm/JVM参数.html":{"url":"jvm/JVM参数.html","title":"JVM参数","keywords":"","body":"JVM参数 标准参数 标准参数，顾名思义，标准参数中包括功能以及输出的结果都是很稳定的，基本上不会随着JVM版本的变化而变化。 我们可以通过 -help 命令来检索出所有标准参数。 C:\\>java-help 用法:java[-options]class [args...] (执行类) 或 java[-options]-jar jarfile[args...] (执行 jar 文件) 其中选项包括: -d32 使用 32位数据模型(如果可用) -d64 使用 64位数据模型(如果可用) -server 选择\"server\"VM 默认 VM 是 server. -cp -classpath 用;分隔的目录,JAR 档案 和 ZIP 档案列表,用于搜索类文件。 -D= 设置系统属性 -verbose:[class|gc|jni] 启用详细输出 -version 输出产品版本并退出 -version: 警告:此功能已过时,将在 未来发行版中删除。 需要指定的版本才能运行 -showversion 输出产品版本并继续 -jre-restrict-search|-no-jre-restrict-search 警告:此功能已过时,将在 未来发行版中删除。 在版本搜索中包括/排除用户专用 JRE -?-help 输出此帮助消息 -X 输出非标准选项的帮助 -ea[:...|:] -enableassertions[:...|:] 按指定的粒度启用断言 -da[:...|:] -disableassertions[:...|:] 禁用具有指定粒度的断言 -esa|-enablesystemassertions 启用系统断言 -dsa|-disablesystemassertions 禁用系统断言 -agentlib:[=] 加载本机代理库,例如-agentlib:hprof 另请参阅-agentlib:jdwp=help 和-agentlib:hprof=help -agentpath:[=] 按完整路径名加载本机代理库 -javaagent:[=] 加载 Java 编程语言代理,请参阅 java.lang.instrument -splash: 使用指定的图像显示启动屏幕 有关详细信息,请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。 X参数 对应前面讲的标准化参数，这是非标准化参数。表示在将来的JVM版本中可能会发生改变，但是这类以-X开始的参数变化的比较小。 我们可以通过 Java -X 命令来检索所有-X 参数。 C:\\Users\\Young>java-X -Xmixed 混合模式执行（默认） -Xint 仅解释模式执行 -Xbootclasspath: 设置引导类和资源的搜索路径 -Xbootclasspath/a: 附加在引导类路径末尾 -Xbootclasspath/p: 置于引导类路径之前 -Xdiag 显示附加诊断消息 -Xnoclassgc 禁用类垃圾收集 -Xincgc 启用增量垃圾收集 -Xloggc: 将 GC 状态记录在文件中（带时间戳） -Xbatch 禁用后台编译 -Xms 设置初始 Java 堆大小 -Xmx 设置最大 Java 堆大小 -Xss 设置 Java 线程堆栈大小 -Xprof 输出 cpu 分析数据 -Xfuture 启用最严格的检查，预计会成为将来的默认值 -Xrs 减少 Java/VM 对操作系统信号的使用（请参阅文档） -Xcheck:jni 对 JNI 函数执行其他检查 -Xshare:off 不尝试使用共享类数据 -Xshare:auto 在可能的情况下使用共享类数据（默认） -Xshare:on 要求使用共享类数据，否则将失败。 -XshowSettings 显示所有设置并继续 -XshowSettings:system （仅限 Linux）显示系统或容器 配置并继续 -XshowSettings:all 显示所有设置并继续 -XshowSettings:vm 显示所有与 vm 相关的设置并继续 -XshowSettings:properties 显示所有属性设置并继续 -XshowSettings:locale 显示所有与区域设置相关的设置并继续 -X 选项是非标准选项。如有更改，恕不另行通知。 XX参数 这是我们日常开发中接触到最多的参数类型。这也是非标准化参数，相对来说不稳定，随着JVM版本的变化可能会发生变化，主要用于JVM调优和debug。 注意：这种参数是我们后续介绍JVM调优讲解最多的参数。 该参数的书写形式又分为两大类：Boolean类型和Key-Value类型 Boolean类型；格式：-XX:[+-] 表示启用或者禁用name属性。例子：-XX:+UseG1GC（表示启用G1垃圾收集器） Key-Value类型：格式：-XX:= 表示name的属性值为value。例子：-XX:MaxGCPauseMillis=500（表示设置GC的最大停顿时间是500ms） 常用参数 // Java运行时数据区设置 -Xms512M：设置堆内存初始值为512M,-X,memory start -Xmx1024M:设置堆内存最大值为1024M,-X,memory max -Xmn10M:设置新生代大小为10M,-X,memory new -Xss128k：设置每个线程的栈大小为128k。-X,stack size -XX:NewRatio=4:设置年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代).设置为4,则年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5 -XX:SurvivorRatio=4:设置年轻代中Eden区与Survivor区的大小比值.设置为4,则两个Survivor区与一个Eden区的比值为2:4,一个Survivor区占整个年轻代的1/6 -XX:MaxPermSize=16m:设置永久代大小为16m,JDK1.8之前 // JDK1.8之前设置永久代 -XX:PermSize=N //方法区 (永久代) 初始大小 -XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen // JDK1.8之后设置元空间 -XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小） -XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小 -XX:MaxTenuringThreshold=0:设置垃圾最大年龄.如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率 // 辅助信息 -XX:+PrintCommandLineFlags // 打印已经被用户或者当前虚拟机设置过的参数 // 堆内存出现OOM的概率是所有内存耗尽异常中最高的，出错时的堆内信息对解决问题非常有帮助，所以给JVM设置这个参数(-XX:+HeapDumpOnOutOfMemoryError)，让JVM遇到OOM异常时能输出堆内信息，并通过（-XX:+HeapDumpPath）参数设置堆内存溢出快照输出的文件地址，这对于特别是对相隔数月才出现的OOM异常尤为重要。 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath -XX:OnOutOfMemoryError // -XX:OnOutOfMemoryError=\"./jconsole.exe\" 表示发生OOM后，运行jconsole.exe程序。利用这个参数，我们可以在系统OOM后，自定义一个脚本，可以用来发送邮件告警信息，可以用来重启系统等等。 // 打印GC信息 -verbose:gc -XX:+PrintGC // 输出形式:[GC 118250K->113543K(130112K), 0.0094143 secs] // [Full GC 121376K->10414K(130112K), 0.0650971 secs] -XX:+PrintGCDetails // 打印详细的GC // 输出形式:[GC [DefNew: 8614K->781K(9088K), 0.0123035 secs] 118250K->113543K(130112K), 0.0124633 secs] // [GC [DefNew: 8614K->8614K(9088K), 0.0000665 secs][Tenured: 112761K->10414K(121024K), 0.0433488 secs] 121376K->10414K(130112K), 0.0436268 secs] -XX:+PrintGCTimeStamps // 与上述两公个混合使用 // 输出形式:11.851: [GC 98328K->93620K(130112K), 0.0082960 secs] -XX:+PrintGCApplicationConcurrentTime:打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用 // 输出形式:Application time: 0.5291524 seconds -XX:+PrintGCApplicationStoppedTime:打印垃圾回收期间程序暂停的时间.可与上面混合使用 // 输出形式:Total time for which application threads were stopped: 0.0468229 seconds -XX:PrintHeapAtGC:打印GC前后的详细堆栈信息 输出形式: 34.702:[GC{Heap before gc invocations=7: def new generation total 55296K,used 52568K[0x1ebd0000,0x227d0000,0x227d0000) eden space 49152K,99%used[0x1ebd0000,0x21bce430,0x21bd0000) from space 6144K,55%used[0x221d0000,0x22527e10,0x227d0000) to space 6144K,0%used[0x21bd0000,0x21bd0000,0x221d0000) tenured generation total 69632K,used 2696K[0x227d0000,0x26bd0000,0x26bd0000) the space 69632K,3%used[0x227d0000,0x22a720f8,0x22a72200,0x26bd0000) compacting perm gen total 8192K,used 2898K[0x26bd0000,0x273d0000,0x2abd0000) the space 8192K,35%used[0x26bd0000,0x26ea4ba8,0x26ea4c00,0x273d0000) ro space 8192K,66%used[0x2abd0000,0x2b12bcc0,0x2b12be00,0x2b3d0000) rw space 12288K,46%used[0x2b3d0000,0x2b972060,0x2b972200,0x2bfd0000) 34.735:[DefNew:52568K->3433K(55296K),0.0072126secs]55264K->6615K(124928K)Heap after gc invocations=8: def new generation total 55296K,used 3433K[0x1ebd0000,0x227d0000,0x227d0000) eden space 49152K,0%used[0x1ebd0000,0x1ebd0000,0x21bd0000) from space 6144K,55%used[0x21bd0000,0x21f2a5e8,0x221d0000) to space 6144K,0%used[0x221d0000,0x221d0000,0x227d0000) tenured generation total 69632K,used 3182K[0x227d0000,0x26bd0000,0x26bd0000) the space 69632K,4%used[0x227d0000,0x22aeb958,0x22aeba00,0x26bd0000) compacting perm gen total 8192K,used 2898K[0x26bd0000,0x273d0000,0x2abd0000) the space 8192K,35%used[0x26bd0000,0x26ea4ba8,0x26ea4c00,0x273d0000) ro space 8192K,66%used[0x2abd0000,0x2b12bcc0,0x2b12be00,0x2b3d0000) rw space 12288K,46%used[0x2b3d0000,0x2b972060,0x2b972200,0x2bfd0000) } ,0.0757599secs] -Xloggc:filename:与上面几个配合使用,把相关日志信息记录到文件以便分析.例如-Xloggc:./gc.log // 垃圾回收器设置 -XX:+UseSerialGC:设置串行收集器 -XX:+UseParallelGC:设置并行收集器 -XX:+UseParalledlOldGC:设置并行年老代收集器 -XX:+UseConcMarkSweepGC:设置并发收集器 -XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数.并行收集线程数. -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间 -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比.公式为1/(1+n) -XX:+CMSIncrementalMode:设置为增量模式.适用于单CPU情况. -XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时,使用的CPU数.并行收集线程数. 经验总结 年轻代大小选择 响应时间优先的应用:尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择).在此种情况下,年轻代收集发生的频率也是最小的.同时,减少到达年老代的对象. 吞吐量优先的应用:尽可能的设置大,可能到达Gbit的程度.因为对响应时间没有要求,垃圾收集可以并行进行,一般适合8CPU以上的应用. 老年代大小选择 响应时间优先的应用: 年老代使用并发收集器,所以其大小需要小心设置,一般要考虑并发会话率和会话持续时间等一些参数.如果堆设置小了,可以会造成内存碎片,高回收频率以及应用暂停。而使用传统的标记清除方式，如果堆大了,则需要较长的收集时间.最优化的方案,一般需要参考以下数据获得: 并发垃圾收集信息 持久代并发收集次数 传统GC信息 花在年轻代和年老代回收上的时间比例 减少年轻代和年老代花费的时间,一般会提高应用的效率 吞吐量优先的应用 一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代. 这样可以尽可能回收掉大部分短期对象,减少中期的对象,而年老代尽存放长期存活对象. 较小堆引起的碎片问题 因为年老代的并发收集器使用标记清除算法,所以不会对堆进行压缩.当收集器回收时,他会把相邻的空间进行合并,这样可以分配给较大的对象.但是当堆空间较小时,运行一段时间以后,就会出现\"碎片\" ,如果并发收集器找不到足够的空间,那么并发收集器将会停止,然后使用传统的标记,清除方式进行回收.如果 出现\"碎片\",可能需要进行如下配置: -XX:+UseCMSCompactAtFullCollection:使用并发收集器时,开启对年老代的压缩. -XX:CMSFullGCsBeforeCompaction=0:上面配置开启的情况下,这里设置多少次Full GC后,对年老代进行压缩 内存使用情况打印的方法: public static String getMemUsage(){ long free=java.lang.Runtime.getRuntime().freeMemory(); long total=java.lang.Runtime.getRuntime().totalMemory(); StringBuffer buf=new StringBuffer(); buf.append(\"[Mem: used \").append((total-free)>>20) .append(\"M free \").append(free>>20) .append(\"M total \").append(total>>20).append(\"M]\"); return buf.toString(); } 堆内存分配 JVM初始分配的内存由-Xms指定,默认是物理内存的1/64; JVM最大分配的内存由-Xmx指定,默认是物理内存的1/4，默认空余堆内存小于40%时,JVM就会增大堆直到-Xmx的最大限制;空余堆内存大于70%时, JVM会减少堆直到-Xms的最小限制.因此服务器一般设置-Xms,-Xmx相等以避免在每次GC后调整堆的大小. 非堆内存分配 JVM使用-XX:PermSize设置非堆内存初始值,默认是物理内存的1/64;由XX:MaxPermSize设置最大非堆内存的大小,默认是物理内存的1/4. JVM内存限制(最大值) 首先JVM内存首先受限于实际的最大物理内存,假设物理内存无限大的话,JVM内存的最大值跟操作系统有很大的关系.简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制,这个限制一般是 2GB-3GB( 一般来说Windows系统下为1.5G-2G,Linux系统下为2G-3G),而64bit以上的处理器就不会有限制了 JVM内存的调优 Heap设定与垃圾回收 Java Heap分为3个区,Young, Old和Permanent。Young保存刚实例化的对象.当该区被填满时,GC会将对象移到Old区.Permanent区则负责保存反射对象,本文不讨论该区.JVM的Heap分配可以使用-X参数设定, -Xms 初始Heap大小 -Xmx java heap最大值 -Xmn young generation的heap大小 JVM有2个GC线程.第一个线程负责回收Heap的Young区.第二个线程在Heap不足时,遍历Heap,将Young区升级为Older区.Older区的大小等于-Xmx减去-Xmn,不能将-Xms的值设的过大,因为第二个线程被迫运行会降低JVM的性能. 为什么一些程序频繁发生GC?有如下原因: 程序内调用了System.gc()或Runtime.gc(). 一些中间件软件调用自己的GC方法,此时需要设置参数禁止这些GC. Java的Heap太小,一般默认的Heap值都很小. 频繁实例化对象,Release对象.此时尽量保存并重用对象,例如使用StringBuffer()和String(). 如果你发现每次GC后,Heap的剩余空间会是总空间的50%,这表示你的Heap处于健康状态.许多Server端的Java程序每次GC后最好能有65%的剩余空间.经验之谈: Server端JVM最好将-Xms和-Xmx设为相同值.为了优化GC,最好让-Xmn值约等于-Xmx的1/3. 一个GUI程序最好是每10到20秒间运行一次GC,每次在半秒之内完成. 注意: 增加Heap的大小虽然会降低GC的频率,但也增加了每次GC的时间.并且GC运行时,所有的用户线程将暂停,也就是GC期间,Java应用程序不做任何工作. Heap大小并不决定进程的内存使用量.进程的内存使用量要大于-Xmx定义的值,因为Java为其他任务分配内存,例如每个线程的Stack等. Stack的设定 每个线程都有他自己的Stack.-Xss 每个线程的Stack大小，Stack的大小限制着线程的数量.如果Stack过大就好导致内存溢漏.-Xss参数决定Stack大小,例如-Xss1024K.如果Stack太小,也会导致Stack溢漏. 硬件环境 硬件环境也影响GC的效率,例如机器的种类,内存,swap空间,和CPU的数量. 如果你的程序需要频繁创建很多transient对象,会导致JVM频繁GC.这种情况你可以增加机器的内存,来减少Swap空间的使用. 4种GC 第一种为单线程GC,也是默认的GC.,该GC适用于单CPU机器. 第二种为Throughput GC,是多线程的GC,适用于多CPU,使用大量线程的程序.第二种GC与第一种GC相似,不同在于GC在收集Young区是多线程的,但在Old区和第一种一样,仍然采用单线程.-XX: +UseParallelGC参数启动该GC. 第三种为Concurrent Low Pause GC,类似于第一种,适用于多CPU,并要求缩短因GC造成程序停滞的时间.这种GC可以在Old区的回收同时,运行应用程序.-XX:+UseConcMarkSweepGC参数启动该GC. 第四种为Incremental Low Pause GC,适用于要求缩短因GC造成程序停滞的时间.这种GC可以在Young区回收的同时,回收一部分Old区对象.-Xincgc参数启动该GC. 参考 Java虚拟机详解（五）------JVM参数（持续更新） 轻松永远记住经典jvm参数 java jvm 参数 -Xms -Xmx -Xmn -Xss 调优总结 powered by GitbookYoung, 该文件最后修改时间： 2022-08-01 12:39:25 "},"jvm/JVM分析工具.html":{"url":"jvm/JVM分析工具.html","title":"JVM分析工具","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2022-08-07 10:04:11 "},"工具使用/idea常用操作.html":{"url":"工具使用/idea常用操作.html","title":"IDEA常用操作","keywords":"","body":" IDEA常用操作 1. 设置类 1.1 设置Ctrl+滚轮 放大/缩小 编辑窗口 2. 快捷键 2.1 编辑 2.2 导航 2.3 搜索 2.4 重构 2.5 Debug 2.6 Git 2.7 通用 3. 骚操作 3.1 列模式 4. Debug操作 IDEA常用操作 1. 设置类 1.1 设置Ctrl+滚轮 放大/缩小 编辑窗口 2. 快捷键 如何查看自己的KeyMap? 下文整理的是windows/linux的格式的快捷键 2.1 编辑 Ctrl + P : 查看方法参数 Ctrl + Q : 查看方法的JavaDoc Alt + Insert : 插入代码 Ctrl + O : 插入重写方法 Ctrl + I : 实现方法 Ctrl + Alt + T : Surround With: 包括代码块 Crl + / : 单行注释 or 取消单行注释 Ctrl + Shift + / : 多行注释 or 取消多行注释 Ctrl + Alt + L : 格式化代码 Ctrl + Alt + O : 自动去除多余的import Ctrl + Alt + I : 自动缩进 Tab : 向后缩进1个制表符 Shift + Tab : 向前缩进1个制表符 Ctrl + X : 剪切当前行 Ctrl + C : 复制当前行 Ctrl + V : 粘贴 Ctrl + Shift + V : 复制的内容的历史记录 Ctrl + D : 复制当前行到下一行 Ctrl + Y : 删除当前行 Ctrl + Shift + [ : 选择当前位置到上一个{的代码 Ctrl + Shift + ] : 选择当前位置到下一个}的代码 Ctrl + Shift + U : 大小写转换 Ctrl + Delete : 删除当前光标后的一个单词、空格等 Ctrl + Backspace : 删除当前光标前的一个单词、空格等 Ctrl + '+' : 展开当前光标所在代码块 Ctrl + '-' : 关闭当前光标所在代码块 Ctrl + Shift + '+' : 展开所有代码块 Ctrl + Shift + '-' : 关闭所有代码块 Ctrl + F4 : 关闭所有编辑的文件 2.2 导航 Esc : 从tool windows回到编辑区 Ctrl + E : 弹窗显示最近打开的文件 Ctrl + Alt + : 后退 or 前进 光标最近移动位置 Ctrl + Alt + B : 进入接口的实现方法中 Ctrl + B or Ctrl + 左键 : 进入方法中，如果是接口则跳到接口上面 Ctrl + U : 跳到父类或者父类的方法 Ctrl + [ or ] : 代码块前后 Ctrl + F12 : 显示类的结构 2.3 搜索 shift + shift : 任意搜索 Ctrl + F : 在当前文件中搜索 Ctrl + R : 替换 Alt + F7 : 查看当前方法/类/变量在何处使用了 2.4 重构 Shift + F6 : 重命名类、方法、变量、常量 Ctrl + F6 : 调整方法参数 Ctrl + Alt + M : 将选中的代码块提取为一个方法 Ctrl + Alt + C : 将选中的代码提取为一个常量 Ctrl + Alt + F : 将选中的代码提取为一个全局变量 Ctrl + Alt + V : 将选中的代码提取为一个局部变量 Ctrl + Alt + P : 将选中的代码提取为方法的参数 2.5 Debug F7 : 进入方法 F8 : 单步调试 2.6 Git Ctrl + T : 提交界面 Ctrl + K : pull Ctrl + Shift + K : push 2.7 通用 Ctrl + Tab : 切换IDEA中的窗口 3. 骚操作 3.1 列模式 当我们需要同时操作多行，比如多行的末尾需要加一个';'，比较优雅的操作即是使用列模式，效果图如下： 其中快捷键Ctrl + -> 或者 Ctrl + 可以使光标移动整个单词，再配合Shift使用，即可选中一个单词 进入列模式，直接Alt + 鼠标右键选中即可 进入列模式的快捷键可以这么查看,同样的快捷键，再操作一次即可推出列模式 4. Debug操作 powered by GitbookYoung, 该文件最后修改时间： 2022-07-17 12:36:49 "}}