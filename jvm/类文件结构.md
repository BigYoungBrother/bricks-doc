# Java类文件结构

## 字节码文件结构

`.java`格式的Java源代码被编译后输出`.class`
格式的字节码，字节码是JVM能够理解的代码。Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且由于字节码并不针对一种特定的机器，因此，Java程序无需重新编译便可在多种操作系统的计算机上运行。

不用语言写成的源代码只要能够编译成字节码的格式并且满足JVM虚拟机的规范，就可以运行在JVM上，如Groovy、Scala和Ruby等语言。

Class文件是以8字节为基础的字节流构成的，其采用了类似C语言的结构体来存储数据，主要有2类数据项：无符号数和表。无符号数用来表述数字、索引引用以及字符串等，u1、u2、u4分别代表1个、2个4个字节的无符号数。表是有多个无符号数以及其他的表组成的复合结构。

根据虚拟机规范，Class文件通过`ClassFile`定义，有点类似C语言的结构体。

`ClassFile`的结构如下：

```java

ClassFile {
    u4             magic;  // 魔数，Class文件的标志
    u2             minor_version; // Class文件的小版本号
    u2             major_version; // Class文件的大版本号
    u2             constant_pool_count; // 常量池的数量
    cp_info        constant_pool[constant_pool_count-1]; // 常量池
    u2             access_flags; // Class的访问标记
    u2             this_class; // 当前类
    u2             super_class; // 父类
    u2             interfaces_count; // 接口数量
    u2             interfaces[interfaces_count]; // 接口
    u2             fields_count; // 字段数量
    field_info     fields[fields_count]; // 字段
    u2             methods_count; // 方法数量
    method_info    methods[methods_count]; // 方法
    u2             attributes_count; //属性数量
    attribute_info attributes[attributes_count]; // 属性
}

```

## 魔数

```java

    u4             magic;  // 魔数，Class文件的标志
    u2             minor_version; // Class文件的小版本号

```

每个Class文件的前4个字节成为魔数(magic number)，其作用是确定这个文件是否是一个能够被虚拟机接受的Class文件，JVM每次都会先检查魔数的值是否为`0xCAFEBABE`，如果不是此固定值，那么JVM会停止加载。

如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：

```java
Error: A JNI error has occurred, please check your installation and try again
Exception in thread "main" java.lang.ClassFormatError: Incompatible magic value 1885430635 in class file StringTest

```

## Class文件版本号

```java
    u2             minor_version; // Class文件的小版本号
    u2             major_version; // Class文件的大版本号
```

魔数后面的4个字节存储的Class文件的版本号，其中第五和第六位是小版本号，第七和第八位为主版本号。它们共同构成了class文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个Class
文件的格式版本号就确定为 M.m

每当Java发布大版本的时候(Java8、Java9这种)，主版本号就会+1。Java 的版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号向上加1。可以使用`javap -v`命令来快速查看Class文件的版本号信息。

高版本的Java虚拟机可以执行低版本的编译器生成的Class文件，但是低版本的Java虚拟机不能执行高版本编译器生成的Class文件，如果低版本的Java虚拟机执行了高版本的编译器生成的Class文件，会报错`class file has wrong version 50.0, should be 49.0`

在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的JDK版本和生产环境中的JDK版本是否一致。

## 常量池

```java

    u2             constant_pool_count; // 常量池的数量
    cp_info        constant_pool[constant_pool_count-1]; // 常量池

```

常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的无符号数，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的,
将第0项常量空出来是有特殊考虑的，索引值为0代表不引用任何一个常量池项。

常量池中每一个常量都是一个表，这14种表有一个共同的特点：开始的第一位是一个u1类型的标志位————tag来标识常量的类型，代表当前这个常量是属于哪种类型的常量类型。

|类型|标志(tag)|描述|
|---|---|---|
|CONSTANT_utf8_info|1|UTF8编码的字符串|
|CONSTANT_Integer_info|3|整形字面量|
|CONSTANT_Float_info|4|浮点型字面量|
|CONSTANT_Long_info|5|长整型字面量|
|CONSTANT_Double_info|6|双精度字面量|
|CONSTANT_Class_info|7|类或接口的符号引用|
|CONSTANT_String_info|8|字符串类型的字面量|
|CONSTANT_Fieldref_info|9|字段的符号引用|
|CONSTANT_Methodref_info|10|类中方法的符号应用|
|CONSTANT_InterfaceMethodref_info|11|接口中方法的符号引用|
|CONSTANT_NameAndType_info|12|字段或方法的符号引用|
|CONSTANT_MethodType_info|16|标志方法类型|
|CONSTANT_MethodHandle_info|15|表示方法句柄|
|CONSTANT_InvokeDynamic_info|18|表示一个动态方法调用点|

常量池主要存放的是: 字面量和符号引用。字面量比较接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等。符号引用则属于编译原理方面的概念，包括有三类常量：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。

描述符：描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，详见下表：（基本数据类型和引用数据类型）

|标识符|含义|
|---|---|
|B|基本数据类型byte|
|C|基本数据类型char|
|D|基本数据类型double|
|F|基本数据类型float|
|I|基本数据类型int|
|J|基本数据类型long|
|S|基本数据类型short|
|Z|基本数据类型boolean|
|V|代表void|
|L|代表对象类型，如Ljava/lang/Object;|
|[|代表数组，如`double[]`表示为`[D`|

在描述符来描述方法时，按照先参数列表后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号内，如：

- java.lang.String toString() 方法描述符为 ()Ljava/lang/String;
- int abc(int[] x, int y) 方法描述符为([II)I

虚拟机在加载Class文件时才会进行动态链接，也就是说Class文件中不会保存各个方法和字段的最终内存布局信息。因此这些字段和方法的符号引用不经过转换时无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。

- 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局有关，引用的目标并不一定已经加载到内存中。
-
直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。

## 访问标志(Access Flag)

## 参考

- [JVM_18_虚拟机的基石:Class文件](https://blog.csdn.net/ZSA222/article/details/122992183)




